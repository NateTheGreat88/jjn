<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroids Game - JNJ Website</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="game.css">
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Back to Home</a>
    
    <div class="game-wrapper">
        <div class="game-ui">
            <div class="ui-left">
                <div id="score">Score: 0</div>
                <div id="highScore">High Score: 0</div>
                <div id="combo" class="combo-display" style="display: none;">COMBO x<span id="comboCount">1</span>!</div>
            </div>
            <div class="ui-center">
                <div id="level">Level 1</div>
                <div id="lives">Lives: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                <div id="powerUp" class="power-up-display" style="display: none;">
                    <span id="powerUpText"></span>
                    <div class="power-up-timer">
                        <div class="power-up-bar" id="powerUpBar"></div>
                    </div>
                </div>
                <div id="bossWarning" class="boss-warning" style="display: none;">
                    <div class="boss-warning-text">‚ö†Ô∏è BOSS INCOMING! ‚ö†Ô∏è</div>
                </div>
                <div id="killStreak" class="kill-streak" style="display: none;">
                    <span id="killStreakText">üî• KILL STREAK!</span>
                </div>
            </div>
            <div class="ui-right">
                <button id="pauseBtn" class="ui-button">‚è∏ Pause</button>
                <button id="soundBtn" class="ui-button sound-btn">üîä Sound</button>
            </div>
        </div>
        
        <div class="game-instructions">
            <p><strong>Controls:</strong> ‚Üê ‚Üí Rotate | ‚Üë Thrust | Space Shoot | P Pause</p>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div id="gameOverScreen" class="game-over-screen" style="display: none;">
            <div class="game-over-content">
                <h2>Game Over!</h2>
                <p class="final-score">Final Score: <span id="finalScore">0</span></p>
                <p class="high-score-text">High Score: <span id="finalHighScore">0</span></p>
                <p class="level-reached">Level Reached: <span id="finalLevel">1</span></p>
                <p class="asteroids-destroyed">Asteroids Destroyed: <span id="finalAsteroids">0</span></p>
                <button id="restartBtn" class="restart-button">üîÑ Play Again</button>
            </div>
        </div>
        
        <div id="pauseScreen" class="pause-screen" style="display: none;">
            <div class="pause-content">
                <h2>‚è∏ Paused</h2>
                <p>Press P to resume</p>
            </div>
        </div>
        
        <div id="levelComplete" class="level-complete" style="display: none;">
            <div class="level-complete-content">
                <h2>Level Complete!</h2>
                <p>Bonus: <span id="levelBonus">0</span> points</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let score = 0;
        let highScore = parseInt(localStorage.getItem('asteroidsHighScore') || '0');
        let level = 1;
        let lives = 3;
        let isPaused = false;
        let isGameOver = false;
        let particles = [];
        let stars = [];
        let powerUps = [];
        let screenShake = { x: 0, y: 0, intensity: 0 };
        let comboCount = 0;
        let comboTime = 0;
        let lastKillTime = 0;
        let activePowerUp = null;
        let powerUpTime = 0;
        let asteroidsDestroyed = 0;
        let soundEnabled = true;
        let bossAsteroid = null;
        let bossSpawned = false;
        let levelCompletePending = false;
        let killStreak = 0;
        let lastKillStreakTime = 0;

        // Audio context for sound effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            if (!soundEnabled) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Initialize stars
        for (let i = 0; i < 200; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2.5 + 0.5,
                speed: Math.random() * 1 + 0.2,
                brightness: Math.random(),
                twinkle: Math.random() * Math.PI * 2
            });
        }

        // Ship
        const ship = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 20,
            angle: -Math.PI / 2,
            rotation: 0,
            speed: 0,
            maxSpeed: 6,
            thrust: 0,
            bullets: [],
            invulnerable: false,
            invulnerableTime: 0,
            shield: false,
            shieldTime: 0,
            trail: []
        };

        // Asteroids
        let asteroids = [];
        const asteroidSizes = [80, 50, 30];

        function createAsteroid(x, y, radius, avoidShip = false, isBoss = false) {
            // Ensure valid coordinates
            if (!x || !y) {
                x = Math.random() * canvas.width;
                y = Math.random() * canvas.height;
            }
            
            // If avoiding ship, ensure safe distance
            if (avoidShip) {
                let attempts = 0;
                while (attempts < 20) {
                    const dist = Math.sqrt((x - ship.x) ** 2 + (y - ship.y) ** 2);
                    if (dist > 200) break; // Safe distance
                    x = Math.random() * canvas.width;
                    y = Math.random() * canvas.height;
                    attempts++;
                }
            }
            
            let a = {
                x: x || Math.random() * canvas.width,
                y: y || Math.random() * canvas.height,
                radius: radius,
                dx: (Math.random() - 0.5) * (2 + level * 0.3),
                dy: (Math.random() - 0.5) * (2 + level * 0.3),
                rotation: (Math.random() - 0.5) * 0.1,
                rotationSpeed: (Math.random() - 0.5) * 0.08,
                vertices: [],
                isBoss: isBoss,
                health: isBoss ? 5 : 1,
                maxHealth: isBoss ? 5 : 1
            };
            
            const numVertices = isBoss ? 16 : (8 + Math.floor(Math.random() * 4));
            for (let i = 0; i < numVertices; i++) {
                const angle = (Math.PI * 2 / numVertices) * i;
                const distance = radius * (0.7 + Math.random() * 0.3);
                a.vertices.push({
                    x: Math.cos(angle) * distance,
                    y: Math.sin(angle) * distance
                });
            }
            
            if (isBoss) {
                bossAsteroid = a;
            } else {
                asteroids.push(a);
            }
        }

        function initLevel() {
            // Clear all asteroids and bullets first
            asteroids = [];
            ship.bullets = [];
            powerUps = [];
            particles = [];
            
            bossAsteroid = null;
            bossSpawned = false;
            
            // Reset ship position to center
            ship.x = canvas.width / 2;
            ship.y = canvas.height / 2;
            ship.speed = 0;
            ship.angle = -Math.PI / 2;
            
            // Give brief invulnerability at level start
            ship.invulnerable = true;
            ship.invulnerableTime = 180;
            
            // Calculate number of asteroids (capped to prevent too many)
            const numAsteroids = Math.min(3 + Math.floor(level * 0.5), 8);
            
            // Spawn asteroids away from ship
            let attempts = 0;
            for (let i = 0; i < numAsteroids; i++) {
                let x, y;
                let validPosition = false;
                attempts = 0;
                
                // Try to find a safe spawn position
                while (!validPosition && attempts < 50) {
                    x = Math.random() * canvas.width;
                    y = Math.random() * canvas.height;
                    
                    // Check distance from ship
                    const dist = Math.sqrt((x - ship.x) ** 2 + (y - ship.y) ** 2);
                    if (dist > 200) { // Safe distance from ship
                        validPosition = true;
                    }
                    attempts++;
                }
                
                // If we couldn't find a safe position, spawn at edges
                if (!validPosition) {
                    const side = Math.floor(Math.random() * 4);
                    switch(side) {
                        case 0: x = 0; y = Math.random() * canvas.height; break;
                        case 1: x = canvas.width; y = Math.random() * canvas.height; break;
                        case 2: x = Math.random() * canvas.width; y = 0; break;
                        case 3: x = Math.random() * canvas.width; y = canvas.height; break;
                    }
                }
                
                createAsteroid(x, y, asteroidSizes[0], false);
            }
        }

        initLevel();

        // Power-up types
        const PowerUpTypes = {
            RAPID_FIRE: 'rapid-fire',
            SHIELD: 'shield',
            MULTI_SHOT: 'multi-shot',
            SLOW_MO: 'slow-mo',
            EXPLOSIVE: 'explosive',
            HOMING: 'homing',
            LASER: 'laser',
            EXTRA_LIFE: 'extra-life'
        };

        function createPowerUp(x, y) {
            if (Math.random() > 0.25) return; // 25% chance
            
            const types = Object.values(PowerUpTypes);
            const type = types[Math.floor(Math.random() * types.length)];
            
            powerUps.push({
                x: x,
                y: y,
                type: type,
                rotation: 0,
                rotationSpeed: 0.05,
                life: 600,
                pulse: 0
            });
        }

        function activatePowerUp(type) {
            activePowerUp = type;
            powerUpTime = 600;
            
            switch(type) {
                case PowerUpTypes.SHIELD:
                    ship.shield = true;
                    ship.shieldTime = 600;
                    break;
                case PowerUpTypes.EXTRA_LIFE:
                    lives++;
                    updateLivesDisplay();
                    createParticles(ship.x, ship.y, '#51cf66', 30, 5, 5);
                    playSound(500, 0.3, 'sine', 0.2);
                    return; // Don't set activePowerUp for extra life
            }
            
            playSound(400, 0.2, 'sine', 0.15);
            updatePowerUpDisplay();
        }

        function updatePowerUpDisplay() {
            const display = document.getElementById('powerUp');
            const text = document.getElementById('powerUpText');
            const bar = document.getElementById('powerUpBar');
            
            if (activePowerUp && powerUpTime > 0) {
                display.style.display = 'block';
                const names = {
                    'rapid-fire': '‚ö° Rapid Fire',
                    'shield': 'üõ°Ô∏è Shield',
                    'multi-shot': 'üî´ Multi Shot',
                    'slow-mo': '‚è±Ô∏è Slow Motion',
                    'explosive': 'üí• Explosive',
                    'homing': 'üéØ Homing',
                    'laser': '‚ö° Laser',
                    'extra-life': '‚ù§Ô∏è Extra Life'
                };
                text.textContent = names[activePowerUp] || activePowerUp;
                bar.style.width = (powerUpTime / 600 * 100) + '%';
            } else {
                display.style.display = 'none';
                activePowerUp = null;
                ship.shield = false;
            }
        }

        // Particles
        function createParticles(x, y, color, count = 15, speed = 4, size = 4) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * speed,
                    dy: (Math.random() - 0.5) * speed,
                    life: 50,
                    maxLife: 50,
                    size: Math.random() * size + 1,
                    color: color,
                    glow: Math.random() > 0.5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2
                });
            }
        }

        function addScreenShake(intensity) {
            screenShake.intensity = Math.max(screenShake.intensity, intensity);
        }

        // Combo system
        function updateCombo() {
            const now = Date.now();
            if (now - lastKillTime < 2000) {
                comboCount++;
                comboTime = 120;
                killStreak++;
            } else {
                comboCount = 1;
                killStreak = 1;
            }
            lastKillTime = now;
            lastKillStreakTime = now;
            
            const comboDisplay = document.getElementById('combo');
            const comboCountDisplay = document.getElementById('comboCount');
            const killStreakDisplay = document.getElementById('killStreak');
            
            if (comboCount > 1) {
                comboDisplay.style.display = 'block';
                comboCountDisplay.textContent = comboCount;
                comboDisplay.style.animation = 'none';
                setTimeout(() => {
                    comboDisplay.style.animation = 'pulse 0.3s ease-out';
                }, 10);
                playSound(200 + comboCount * 50, 0.1, 'sine', 0.1);
            } else {
                comboDisplay.style.display = 'none';
            }
            
            // Kill streak display
            if (killStreak >= 5) {
                killStreakDisplay.style.display = 'block';
                killStreakDisplay.style.animation = 'none';
                setTimeout(() => {
                    killStreakDisplay.style.animation = 'pulse 0.5s ease-out';
                }, 10);
            } else {
                killStreakDisplay.style.display = 'none';
            }
        }

        // Key handling
        const keys = {};
        document.addEventListener("keydown", e => {
            keys[e.code] = true;
            if (e.code === "KeyP") {
                togglePause();
            }
        });
        document.addEventListener("keyup", e => keys[e.code] = false);

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        function togglePause() {
            if (isGameOver) return;
            isPaused = !isPaused;
            document.getElementById('pauseScreen').style.display = isPaused ? 'flex' : 'none';
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').textContent = soundEnabled ? 'üîä Sound' : 'üîá Muted';
        }

        function spawnBoss() {
            if (bossSpawned || bossAsteroid) return;
            
            bossSpawned = true;
            const warning = document.getElementById('bossWarning');
            warning.style.display = 'block';
            playSound(150, 0.5, 'sawtooth', 0.2);
            
            setTimeout(() => {
                warning.style.display = 'none';
                createAsteroid(canvas.width / 2, -100, 120, false, true);
                playSound(100, 0.3, 'square', 0.25);
            }, 2000);
        }

        function update() {
            if (isPaused || isGameOver) {
                requestAnimationFrame(update);
                return;
            }

            // Spawn boss every 5 levels (only if level complete is not pending)
            if (level % 5 === 0 && !bossSpawned && asteroids.length === 0 && !bossAsteroid && !levelCompletePending) {
                spawnBoss();
            }

            // Update screen shake
            if (screenShake.intensity > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.intensity *= 0.9;
            } else {
                screenShake.x = 0;
                screenShake.y = 0;
            }

            // Update stars
            stars.forEach(star => {
                star.y += star.speed;
                star.twinkle += 0.05;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });

            // Update combo
            if (comboTime > 0) comboTime--;
            if (comboTime <= 0 && comboCount > 1) {
                comboCount = 0;
                document.getElementById('combo').style.display = 'none';
            }
            
            // Update kill streak
            const now = Date.now();
            if (now - lastKillStreakTime > 3000) {
                killStreak = 0;
                document.getElementById('killStreak').style.display = 'none';
            }

            // Update power-up
            if (powerUpTime > 0) {
                powerUpTime--;
                updatePowerUpDisplay();
            }

            // Ship rotation and thrust
            if (keys["ArrowLeft"]) ship.rotation = -0.08;
            else if (keys["ArrowRight"]) ship.rotation = 0.08;
            else ship.rotation *= 0.9;

            if (keys["ArrowUp"]) {
                ship.thrust = 0.15;
                // Ship trail
                ship.trail.push({
                    x: ship.x - Math.cos(ship.angle) * 25,
                    y: ship.y - Math.sin(ship.angle) * 25,
                    life: 10
                });
                if (ship.trail.length > 5) ship.trail.shift();
                
                if (Math.random() > 0.5) {
                    const thrusterX = ship.x - Math.cos(ship.angle) * 25;
                    const thrusterY = ship.y - Math.sin(ship.angle) * 25;
                    createParticles(thrusterX, thrusterY, '#4a9eff', 4, 3, 3);
                }
            } else {
                ship.thrust = 0;
            }

            // Update trail
            ship.trail = ship.trail.filter(t => {
                t.life--;
                return t.life > 0;
            });

            ship.angle += ship.rotation;
            ship.speed += ship.thrust;
            ship.speed = Math.min(ship.speed, ship.maxSpeed);
            ship.x += Math.cos(ship.angle) * ship.speed;
            ship.y += Math.sin(ship.angle) * ship.speed;

            ship.speed *= 0.98;

            // Screen wrap
            if (ship.x < 0) ship.x = canvas.width;
            if (ship.x > canvas.width) ship.x = 0;
            if (ship.y < 0) ship.y = canvas.height;
            if (ship.y > canvas.height) ship.y = 0;

            // Update invulnerability
            if (ship.invulnerable) {
                ship.invulnerableTime--;
                if (ship.invulnerableTime <= 0) {
                    ship.invulnerable = false;
                }
            }

            if (ship.shield) {
                ship.shieldTime--;
                if (ship.shieldTime <= 0) {
                    ship.shield = false;
                }
            }

            // Shooting bullets
            const maxBullets = activePowerUp === PowerUpTypes.RAPID_FIRE ? 15 : 
                              activePowerUp === PowerUpTypes.LASER ? 3 : 8;
            const shootCooldown = activePowerUp === PowerUpTypes.RAPID_FIRE ? 3 : 
                                 activePowerUp === PowerUpTypes.LASER ? 5 : 10;
            
            if (keys["Space"] && ship.bullets.length < maxBullets) {
                const bulletSpeed = activePowerUp === PowerUpTypes.LASER ? 12 : 8;
                const shots = activePowerUp === PowerUpTypes.MULTI_SHOT ? 3 : 1;
                
                for (let i = 0; i < shots; i++) {
                    const angleOffset = shots > 1 ? (i - 1) * 0.3 : 0;
                    
                    // Find nearest asteroid for homing
                    let targetAsteroid = null;
                    if (activePowerUp === PowerUpTypes.HOMING && asteroids.length > 0) {
                        let minDist = Infinity;
                        asteroids.forEach(a => {
                            const dist = Math.sqrt((a.x - ship.x) ** 2 + (a.y - ship.y) ** 2);
                            if (dist < minDist) {
                                minDist = dist;
                                targetAsteroid = a;
                            }
                        });
                    }
                    
                    const bulletAngle = targetAsteroid ? 
                        Math.atan2(targetAsteroid.y - ship.y, targetAsteroid.x - ship.x) :
                        ship.angle + angleOffset;
                    
                    ship.bullets.push({
                        x: ship.x + Math.cos(bulletAngle) * 25,
                        y: ship.y + Math.sin(bulletAngle) * 25,
                        dx: Math.cos(bulletAngle) * bulletSpeed,
                        dy: Math.sin(bulletAngle) * bulletSpeed,
                        life: activePowerUp === PowerUpTypes.LASER ? 90 : 60,
                        explosive: activePowerUp === PowerUpTypes.EXPLOSIVE,
                        laser: activePowerUp === PowerUpTypes.LASER,
                        homing: activePowerUp === PowerUpTypes.HOMING,
                        target: targetAsteroid,
                        size: activePowerUp === PowerUpTypes.LASER ? 5 : 3
                    });
                }
                
                playSound(activePowerUp === PowerUpTypes.LASER ? 1000 : 800, 0.05, 'square', 0.1);
                if (shootCooldown > 0) {
                    keys["Space"] = false;
                }
            }

            // Update bullets
            ship.bullets = ship.bullets.filter(b => {
                // Homing bullet logic
                if (b.homing && b.target && asteroids.includes(b.target)) {
                    const dx = b.target.x - b.x;
                    const dy = b.target.y - b.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        const angle = Math.atan2(dy, dx);
                        const turnSpeed = 0.15;
                        const currentAngle = Math.atan2(b.dy, b.dx);
                        let newAngle = currentAngle;
                        
                        // Calculate angle difference
                        let angleDiff = angle - currentAngle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        
                        newAngle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnSpeed);
                        
                        const speed = Math.sqrt(b.dx*b.dx + b.dy*b.dy);
                        b.dx = Math.cos(newAngle) * speed;
                        b.dy = Math.sin(newAngle) * speed;
                    }
                }
                
                b.x += b.dx;
                b.y += b.dy;
                b.life--;
                return b.life > 0 && b.x > -50 && b.x < canvas.width + 50 && b.y > -50 && b.y < canvas.height + 50;
            });

            // Update power-ups
            powerUps.forEach((pu, idx) => {
                pu.rotation += pu.rotationSpeed;
                pu.pulse += 0.1;
                pu.life--;
                
                const dx = ship.x - pu.x;
                const dy = ship.y - pu.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < ship.radius + 15) {
                    activatePowerUp(pu.type);
                    createParticles(pu.x, pu.y, '#ffc107', 25, 5, 5);
                    powerUps.splice(idx, 1);
                }
            });
            powerUps = powerUps.filter(pu => pu.life > 0);

            // Update asteroids
            const slowMo = activePowerUp === PowerUpTypes.SLOW_MO ? 0.5 : 1;
            
            asteroids.forEach((a, i) => {
                a.x += a.dx * slowMo;
                a.y += a.dy * slowMo;
                a.rotation += a.rotationSpeed * slowMo;

                if (a.x < -a.radius) a.x = canvas.width + a.radius;
                if (a.x > canvas.width + a.radius) a.x = -a.radius;
                if (a.y < -a.radius) a.y = canvas.height + a.radius;
                if (a.y > canvas.height + a.radius) a.y = -a.radius;

                // Collision with ship
                if (!ship.invulnerable && !ship.shield) {
                    let dx = ship.x - a.x;
                    let dy = ship.y - a.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < ship.radius + a.radius) {
                        lives--;
                        ship.invulnerable = true;
                        ship.invulnerableTime = 120;
                        addScreenShake(15);
                        createParticles(ship.x, ship.y, '#ff4d4d', 40, 6, 5);
                        playSound(150, 0.3, 'sawtooth', 0.2);
                        
                        if (lives <= 0) {
                            gameOver();
                            return;
                        }
                        
                        updateLivesDisplay();
                    }
                }

                // Bullet collision
                ship.bullets.forEach((b, j) => {
                    let dx = b.x - a.x;
                    let dy = b.y - a.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < a.radius) {
                        updateCombo();
                        const baseScore = Math.floor(100 / a.radius);
                        const comboMultiplier = comboCount;
                        const streakBonus = killStreak >= 10 ? 2 : killStreak >= 5 ? 1.5 : 1;
                        const points = Math.floor(baseScore * comboMultiplier * streakBonus);
                        score += points;
                        asteroidsDestroyed++;
                        
                        if (score > highScore) {
                            highScore = score;
                            localStorage.setItem('asteroidsHighScore', highScore.toString());
                        }
                        updateScore();
                        
                        addScreenShake(8);
                        playSound(300, 0.1, 'square', 0.15);
                        
                        // Explosive bullets
                        if (b.explosive) {
                            createParticles(a.x, a.y, '#ff4d4d', 30, 8, 6);
                            // Damage nearby asteroids (but limit to prevent too many)
                            const nearbyAsteroids = [];
                            asteroids.forEach((otherA, oi) => {
                                if (oi !== i) {
                                    const odx = otherA.x - a.x;
                                    const ody = otherA.y - a.y;
                                    const odist = Math.sqrt(odx*odx + ody*ody);
                                    if (odist < 100) {
                                        nearbyAsteroids.push(oi);
                                    }
                                }
                            });
                            
                            // Limit explosive chain to prevent too many asteroids
                            const maxChain = 3;
                            nearbyAsteroids.slice(0, maxChain).forEach(oi => {
                                createParticles(asteroids[oi].x, asteroids[oi].y, '#ffc107', 15, 5, 4);
                                asteroids.splice(oi, 1);
                                asteroidsDestroyed++;
                            });
                        } else {
                            createParticles(a.x, a.y, '#ffc107', 20, 5, 4);
                        }
                        
                        ship.bullets.splice(j, 1);
                        asteroids.splice(i, 1);

                        createPowerUp(a.x, a.y);

                        // Split asteroid (only if not too small and not too many asteroids)
                        if (a.radius > 30 && asteroids.length < 20) {
                            const newRadius = a.radius / 2;
                            const offset1 = (Math.random() - 0.5) * 30;
                            const offset2 = (Math.random() - 0.5) * 30;
                            createAsteroid(a.x + offset1, a.y + offset2, newRadius, false);
                            createAsteroid(a.x - offset1, a.y - offset2, newRadius, false);
                        }
                    }
                });
            });

            // Update boss asteroid
            if (bossAsteroid) {
                bossAsteroid.x += bossAsteroid.dx * slowMo;
                bossAsteroid.y += bossAsteroid.dy * slowMo;
                bossAsteroid.rotation += bossAsteroid.rotationSpeed * slowMo;

                // Boss movement pattern
                if (bossAsteroid.y < canvas.height * 0.3) {
                    bossAsteroid.dy = Math.abs(bossAsteroid.dy);
                }
                if (bossAsteroid.y > canvas.height * 0.7) {
                    bossAsteroid.dy = -Math.abs(bossAsteroid.dy);
                }

                // Wrap boss
                if (bossAsteroid.x < -bossAsteroid.radius) bossAsteroid.x = canvas.width + bossAsteroid.radius;
                if (bossAsteroid.x > canvas.width + bossAsteroid.radius) bossAsteroid.x = -bossAsteroid.radius;

                // Collision with ship
                if (!ship.invulnerable && !ship.shield) {
                    let dx = ship.x - bossAsteroid.x;
                    let dy = ship.y - bossAsteroid.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < ship.radius + bossAsteroid.radius) {
                        lives--;
                        ship.invulnerable = true;
                        ship.invulnerableTime = 120;
                        addScreenShake(20);
                        createParticles(ship.x, ship.y, '#ff4d4d', 50, 8, 6);
                        playSound(100, 0.4, 'sawtooth', 0.25);
                        
                        if (lives <= 0) {
                            gameOver();
                            return;
                        }
                        updateLivesDisplay();
                    }
                }

                // Bullet collision with boss
                ship.bullets.forEach((b, j) => {
                    let dx = b.x - bossAsteroid.x;
                    let dy = b.y - bossAsteroid.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < bossAsteroid.radius) {
                        bossAsteroid.health--;
                        addScreenShake(10);
                        playSound(200, 0.15, 'square', 0.2);
                        createParticles(bossAsteroid.x, bossAsteroid.y, '#ff4d4d', 25, 6, 5);
                        ship.bullets.splice(j, 1);

                        if (bossAsteroid.health <= 0) {
                            score += 1000 * level;
                            asteroidsDestroyed++;
                            addScreenShake(25);
                            playSound(100, 0.5, 'sawtooth', 0.3);
                            createParticles(bossAsteroid.x, bossAsteroid.y, '#ffc107', 60, 10, 6);
                            bossAsteroid = null;
                            bossSpawned = false;
                            updateScore();
                        }
                    }
                });
            }

            // Check for level complete (only if no asteroids and no boss, and no bullets in flight)
            if (asteroids.length === 0 && !bossAsteroid && ship.bullets.length === 0) {
                // Small delay to ensure all asteroids are cleared
                if (!window.levelCompletePending) {
                    window.levelCompletePending = true;
                    
                    setTimeout(() => {
                        // Double check asteroids are still cleared
                        if (asteroids.length === 0 && !bossAsteroid) {
                            const bonus = 500 * level;
                            score += bonus;
                            updateScore();
                            
                            // Show level complete
                            document.getElementById('levelBonus').textContent = bonus.toLocaleString();
                            document.getElementById('levelComplete').style.display = 'flex';
                            playSound(600, 0.3, 'sine', 0.2);
                            
                            setTimeout(() => {
                                document.getElementById('levelComplete').style.display = 'none';
                                level++;
                                updateLevel();
                                window.levelCompletePending = false;
                                initLevel();
                            }, 2000);
                        } else {
                            window.levelCompletePending = false;
                        }
                    }, 500);
                }
            }

            // Update particles
            particles = particles.filter(p => {
                p.x += p.dx;
                p.y += p.dy;
                p.life--;
                p.rotation += p.rotationSpeed;
                p.dx *= 0.98;
                p.dy *= 0.98;
                return p.life > 0;
            });

            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);
            
            // Clear with fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars with twinkle
            stars.forEach(star => {
                const brightness = 0.3 + Math.sin(star.twinkle) * 0.2 + star.brightness * 0.5;
                ctx.globalAlpha = brightness;
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw particles
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;
                ctx.globalAlpha = alpha;
                
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                
                if (p.glow) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = p.color;
                }
                
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(0, 0, p.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Draw power-ups
            powerUps.forEach(pu => {
                ctx.save();
                ctx.translate(pu.x, pu.y);
                ctx.rotate(pu.rotation);
                
                const pulseSize = 15 + Math.sin(pu.pulse) * 3;
                const colors = {
                    'rapid-fire': '#ff4d4d',
                    'shield': '#4a9eff',
                    'multi-shot': '#ffc107',
                    'slow-mo': '#51cf66',
                    'explosive': '#ff6b6b'
                };
                
                ctx.strokeStyle = colors[pu.type] || '#fff';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                ctx.shadowColor = colors[pu.type] || '#fff';
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = colors[pu.type] || '#fff';
                ctx.globalAlpha = 0.2;
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
                
                ctx.restore();
            });

            // Draw ship trail
            ship.trail.forEach((t, i) => {
                const alpha = t.life / 10;
                ctx.globalAlpha = alpha * 0.5;
                ctx.fillStyle = '#4a9eff';
                ctx.beginPath();
                ctx.arc(t.x, t.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw ship
            if (!ship.invulnerable || Math.floor(ship.invulnerableTime / 5) % 2 === 0) {
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);
                
                // Shield effect
                if (ship.shield) {
                    ctx.strokeStyle = '#4a9eff';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.6;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#4a9eff';
                    ctx.beginPath();
                    ctx.arc(0, 0, ship.radius + 12, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }
                
                // Ship body with gradient
                const gradient = ctx.createLinearGradient(20, 0, -15, 0);
                gradient.addColorStop(0, '#8bc5ff');
                gradient.addColorStop(0.5, '#4a9eff');
                gradient.addColorStop(1, '#2563eb');
                
                ctx.strokeStyle = "#4a9eff";
                ctx.lineWidth = 2.5;
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#4a9eff';
                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(-15, 12);
                ctx.lineTo(-10, 0);
                ctx.lineTo(-15, -12);
                ctx.closePath();
                ctx.stroke();
                
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.restore();
            }

            // Draw bullets with glow
            ship.bullets.forEach(b => {
                if (b.laser) {
                    // Laser beam effect
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ffff';
                    ctx.beginPath();
                    ctx.moveTo(ship.x, ship.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#00ffff';
                    ctx.shadowBlur = 10;
                } else if (b.homing) {
                    ctx.fillStyle = '#ff00ff';
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff00ff';
                } else {
                    ctx.fillStyle = "#ff4d4d";
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff4d4d';
                }
                
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size || 3, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Draw asteroids
            asteroids.forEach(a => {
                drawAsteroid(a);
            });

            // Draw boss asteroid
            if (bossAsteroid) {
                drawAsteroid(bossAsteroid, true);
                
                // Boss health bar
                const barWidth = 200;
                const barHeight = 10;
                const barX = bossAsteroid.x - barWidth / 2;
                const barY = bossAsteroid.y - bossAsteroid.radius - 30;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const healthPercent = bossAsteroid.health / bossAsteroid.maxHealth;
                ctx.fillStyle = healthPercent > 0.5 ? '#51cf66' : healthPercent > 0.25 ? '#ffc107' : '#ff4d4d';
                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }
            
            ctx.restore();
        }

        function drawAsteroid(a, isBoss = false) {
            ctx.save();
            ctx.translate(a.x, a.y);
            ctx.rotate(a.rotation);
            
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, a.radius);
            if (isBoss) {
                gradient.addColorStop(0, 'rgba(255, 77, 77, 0.6)');
                gradient.addColorStop(0.5, 'rgba(255, 77, 77, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 77, 77, 0.1)');
                ctx.strokeStyle = "#ff4d4d";
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff4d4d';
                
                // Boss pulsing effect
                const pulse = Math.sin(Date.now() / 200) * 2;
                ctx.scale(1 + pulse * 0.05, 1 + pulse * 0.05);
            } else {
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
                gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
                ctx.strokeStyle = "#e0e0e0";
                ctx.lineWidth = 2;
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ffffff';
            }
            
            ctx.beginPath();
            ctx.moveTo(a.vertices[0].x, a.vertices[0].y);
            for (let i = 1; i < a.vertices.length; i++) {
                ctx.lineTo(a.vertices[i].x, a.vertices[i].y);
            }
            ctx.closePath();
            ctx.stroke();
            
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.restore();
        }

        function updateScore() {
            document.getElementById("score").innerText = `Score: ${score.toLocaleString()}`;
            document.getElementById("highScore").innerText = `High Score: ${highScore.toLocaleString()}`;
        }

        function updateLevel() {
            document.getElementById("level").innerText = `Level ${level}`;
        }

        function updateLivesDisplay() {
            const hearts = '‚ù§Ô∏è'.repeat(lives);
            document.getElementById("lives").innerText = `Lives: ${hearts}`;
        }

        function gameOver() {
            isGameOver = true;
            document.getElementById("finalScore").textContent = score.toLocaleString();
            document.getElementById("finalHighScore").textContent = highScore.toLocaleString();
            document.getElementById("finalLevel").textContent = level;
            document.getElementById("finalAsteroids").textContent = asteroidsDestroyed.toLocaleString();
            document.getElementById("gameOverScreen").style.display = 'flex';
            playSound(150, 0.5, 'sawtooth', 0.3);
        }

        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        document.getElementById('soundBtn').addEventListener('click', toggleSound);
        document.getElementById('restartBtn').addEventListener('click', () => {
            location.reload();
        });

        updateScore();
        updateLivesDisplay();

        update();
        
        // Cursor Trail Effect
        const trails = [];
        const maxTrails = 50;
        let lastTime = 0;
        
        function createCursorTrail(x, y) {
            const trail = document.createElement('div');
            trail.className = 'cursor-trail';
            trail.style.left = x + 'px';
            trail.style.top = y + 'px';
            trail.style.opacity = '0.6';
            document.body.appendChild(trail);
            
            requestAnimationFrame(() => {
                trail.style.opacity = '0';
                trail.style.transform = 'translate(-50%, -50%) scale(0.2)';
            });
            
            setTimeout(() => {
                if (trail.parentNode) {
                    trail.remove();
                }
            }, 800);
            
            trails.push(trail);
            if (trails.length > maxTrails) {
                const oldTrail = trails.shift();
                if (oldTrail && oldTrail.parentNode) {
                    oldTrail.remove();
                }
            }
        }
        
        let lastX = 0;
        let lastY = 0;
        
        document.addEventListener('mousemove', (e) => {
            const now = Date.now();
            if (now - lastTime > 8) {
                const distance = Math.sqrt(
                    Math.pow(e.clientX - lastX, 2) + Math.pow(e.clientY - lastY, 2)
                );
                
                if (distance > 2) {
                    createCursorTrail(e.clientX, e.clientY);
                    lastX = e.clientX;
                    lastY = e.clientY;
                    lastTime = now;
                }
            }
        });
    </script>
</body>
</html>
