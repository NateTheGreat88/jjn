<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Editor - JNJ Website</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="imageeditor.css">
    <script src="page-transitions.js" defer></script>
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Back to Home</a>
    
    <div class="editor-container">
        <header class="editor-header">
            <h1>JNJ Image Editor</h1>
            <p class="editor-subtitle">Create and edit images</p>
        </header>

        <div class="editor-wrapper">
            <div class="toolbar">
                <div class="tool-section">
                    <h3>File</h3>
                    <div class="tool-group">
                        <input type="file" id="imageUpload" accept="image/*" style="display: none;">
                        <button class="tool-btn" onclick="document.getElementById('imageUpload').click()">üìÅ Load Image</button>
                        <button class="tool-btn" onclick="newCanvas()">üÜï New Canvas</button>
                        <button class="tool-btn" onclick="downloadImage()">üíæ Download</button>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>Tools</h3>
                    <div class="tool-group">
                        <button class="tool-btn active" id="brushTool" onclick="setTool('brush')">üñåÔ∏è Brush</button>
                        <button class="tool-btn" id="eraserTool" onclick="setTool('eraser')">üßπ Eraser</button>
                        <button class="tool-btn" id="lineTool" onclick="setTool('line')">üìè Line</button>
                        <button class="tool-btn" id="rectTool" onclick="setTool('rect')">‚¨ú Rectangle</button>
                        <button class="tool-btn" id="circleTool" onclick="setTool('circle')">‚≠ï Circle</button>
                        <button class="tool-btn" id="textTool" onclick="setTool('text')">üìù Text</button>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>Colors</h3>
                    <div class="tool-group">
                        <input type="color" id="colorPicker" value="#4a9eff" onchange="updateColor(this.value)">
                        <input type="text" id="colorInput" class="color-input" value="#4a9eff" onchange="updateColor(this.value)">
                    </div>
                </div>

                <div class="tool-section">
                    <h3>Brush Size</h3>
                    <div class="tool-group">
                        <input type="range" id="brushSize" min="1" max="50" value="5" oninput="updateBrushSize(this.value)">
                        <span id="brushSizeDisplay">5px</span>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>Filters</h3>
                    <div class="tool-group">
                        <button class="tool-btn" onclick="applyFilter('grayscale')">‚ö´ Grayscale</button>
                        <button class="tool-btn" onclick="applyFilter('sepia')">üü§ Sepia</button>
                        <button class="tool-btn" onclick="applyFilter('invert')">üîÑ Invert</button>
                        <button class="tool-btn" onclick="applyFilter('brightness')">‚òÄÔ∏è Brightness</button>
                        <button class="tool-btn" onclick="resetFilters()">‚Ü©Ô∏è Reset</button>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>Actions</h3>
                    <div class="tool-group">
                        <button class="tool-btn" onclick="undo()">‚Ü∂ Undo</button>
                        <button class="tool-btn" onclick="clearCanvas()">üóëÔ∏è Clear</button>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>Zoom</h3>
                    <div class="tool-group">
                        <button class="tool-btn" onclick="zoomIn()">üîç+ Zoom In</button>
                        <button class="tool-btn" onclick="zoomOut()">üîç- Zoom Out</button>
                        <button class="tool-btn" onclick="resetZoom()">üéØ Reset</button>
                        <div class="zoom-display">
                            <span id="zoomLevel">100%</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="canvas-container" id="canvasContainer">
                <canvas id="canvas"></canvas>
                <div class="canvas-overlay" id="canvasOverlay"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('canvasOverlay');
        const imageUpload = document.getElementById('imageUpload');
        
        let currentTool = 'brush';
        let isDrawing = false;
        let startX, startY;
        let currentColor = '#4a9eff';
        let brushSize = 5;
        let history = [];
        let textInput = null;
        let zoomLevel = 1.0; // Current zoom level (1.0 = 100%)
        const MIN_ZOOM = 0.25; // 25% minimum
        const MAX_ZOOM = 4.0; // 400% maximum
        const ZOOM_STEP = 0.25; // 25% increments
        let baseCanvasWidth = 800;
        let baseCanvasHeight = 600;

        // Initialize canvas
        function initCanvas() {
            canvas.width = 800;
            canvas.height = 600;
            baseCanvasWidth = 800;
            baseCanvasHeight = 600;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = brushSize;
            saveState();
            resizeCanvas();
            applyZoom(); // Apply zoom after resize
        }

        // Resize canvas to fit container (only if zoom is at 100%)
        function resizeCanvas() {
            if (zoomLevel === 1.0) {
                const container = canvas.parentElement;
                const maxWidth = container.clientWidth - 40;
                const maxHeight = window.innerHeight - 200;
                const scale = Math.min(maxWidth / canvas.width, maxHeight / canvas.height, 1);
                // Store the display size, but don't override zoom
                if (scale < 1) {
                    canvas.style.width = (canvas.width * scale) + 'px';
                    canvas.style.height = (canvas.height * scale) + 'px';
                } else {
                    canvas.style.width = canvas.width + 'px';
                    canvas.style.height = canvas.height + 'px';
                }
            }
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            if (zoomLevel !== 1.0) {
                applyZoom(); // Reapply zoom on resize
            }
        });

        // Get canvas coordinates from mouse event
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        // Set active tool
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');
            
            if (tool === 'text') {
                canvas.style.cursor = 'text';
            } else {
                canvas.style.cursor = 'crosshair';
            }
        }

        // Update color
        function updateColor(color) {
            currentColor = color;
            document.getElementById('colorPicker').value = color;
            document.getElementById('colorInput').value = color;
        }

        // Update brush size
        function updateBrushSize(size) {
            brushSize = parseInt(size);
            document.getElementById('brushSizeDisplay').textContent = size + 'px';
        }

        // Save canvas state for undo
        function saveState() {
            history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            if (history.length > 20) {
                history.shift();
            }
        }

        // Undo
        function undo() {
            if (history.length > 1) {
                history.pop();
                ctx.putImageData(history[history.length - 1], 0, 0);
            }
        }

        // Clear canvas
        function clearCanvas() {
            if (confirm('Clear the entire canvas?')) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                saveState();
            }
        }

        // New canvas
        function newCanvas() {
            if (confirm('Create a new canvas? Current work will be lost.')) {
                initCanvas();
            }
        }

        // Load image
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        baseCanvasWidth = img.width;
                        baseCanvasHeight = img.height;
                        ctx.drawImage(img, 0, 0);
                        saveState();
                        resizeCanvas();
                        applyZoom(); // Reapply zoom with new dimensions
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Drawing functions
        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            const coords = getCanvasCoordinates(e);
            startX = coords.x;
            startY = coords.y;

            if (currentTool === 'brush' || currentTool === 'eraser') {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
            } else if (currentTool === 'text') {
                addText(startX, startY);
                isDrawing = false;
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();

            const coords = getCanvasCoordinates(e);
            const currentX = coords.x;
            const currentY = coords.y;

            if (currentTool === 'brush') {
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(currentX, currentY);
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(currentX, currentY);
                ctx.globalCompositeOperation = 'source-over';
            } else if (currentTool === 'line' || currentTool === 'rect' || currentTool === 'circle') {
                // Preview will be drawn on mouseup
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            e.preventDefault();
            isDrawing = false;

            const coords = getCanvasCoordinates(e);
            const endX = coords.x;
            const endY = coords.y;

            if (currentTool === 'line') {
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                saveState();
            } else if (currentTool === 'rect') {
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.strokeRect(startX, startY, endX - startX, endY - startY);
                saveState();
            } else if (currentTool === 'circle') {
                const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.beginPath();
                ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
                ctx.stroke();
                saveState();
            } else {
                saveState();
            }
        }

        // Add text
        function addText(x, y) {
            const text = prompt('Enter text:');
            if (text) {
                ctx.fillStyle = currentColor;
                ctx.font = `${brushSize * 4}px 'Courier New', monospace`;
                ctx.fillText(text, x, y);
                saveState();
            }
        }

        // Apply filters
        function applyFilter(filter) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                if (filter === 'grayscale') {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray;
                    data[i + 1] = gray;
                    data[i + 2] = gray;
                } else if (filter === 'sepia') {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                    data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                    data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                } else if (filter === 'invert') {
                    data[i] = 255 - data[i];
                    data[i + 1] = 255 - data[i + 1];
                    data[i + 2] = 255 - data[i + 2];
                } else if (filter === 'brightness') {
                    const brightness = 30;
                    data[i] = Math.min(255, data[i] + brightness);
                    data[i + 1] = Math.min(255, data[i + 1] + brightness);
                    data[i + 2] = Math.min(255, data[i + 2] + brightness);
                }
            }

            ctx.putImageData(imageData, 0, 0);
            saveState();
        }

        // Reset filters
        function resetFilters() {
            if (history.length > 0) {
                ctx.putImageData(history[history.length - 1], 0, 0);
            }
        }

        // Zoom Functions
        function zoomIn() {
            if (zoomLevel < MAX_ZOOM) {
                zoomLevel = Math.min(zoomLevel + ZOOM_STEP, MAX_ZOOM);
                applyZoom();
            }
        }

        function zoomOut() {
            if (zoomLevel > MIN_ZOOM) {
                zoomLevel = Math.max(zoomLevel - ZOOM_STEP, MIN_ZOOM);
                applyZoom();
            }
        }

        function resetZoom() {
            zoomLevel = 1.0;
            applyZoom();
        }

        function applyZoom() {
            // Apply zoom only to the canvas element itself
            // Keep container size fixed so it doesn't cover buttons
            // Calculate base display size (fit to container at 100%)
            const container = canvas.parentElement;
            const maxWidth = container.clientWidth - 40;
            const maxHeight = window.innerHeight - 200;
            const baseScale = Math.min(maxWidth / baseCanvasWidth, maxHeight / baseCanvasHeight, 1);
            
            // Apply zoom to the base display size
            const displayWidth = (baseCanvasWidth * baseScale * zoomLevel);
            const displayHeight = (baseCanvasHeight * baseScale * zoomLevel);
            
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            canvas.style.maxWidth = 'none';
            canvas.style.maxHeight = 'none';
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            const zoomLevelDisplay = document.getElementById('zoomLevel');
            zoomLevelDisplay.textContent = Math.round(zoomLevel * 100) + '%';
        }

        // Keyboard shortcuts for zoom (Ctrl/Cmd + Plus/Minus/0)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && !e.shiftKey) {
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoomIn();
                } else if (e.key === '-') {
                    e.preventDefault();
                    zoomOut();
                } else if (e.key === '0') {
                    e.preventDefault();
                    resetZoom();
                }
            }
        });

        // Mouse wheel zoom (Ctrl/Cmd + Scroll)
        const canvasContainer = document.getElementById('canvasContainer');
        canvasContainer.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            }
        }, { passive: false });

        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'jnj-image-' + Date.now() + '.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        // Event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {
                bubbles: true
            });
            canvas.dispatchEvent(mouseEvent);
        });

        // Initialize
        initCanvas();
        updateZoomDisplay(); // Initialize zoom display
        
        // Cursor Trail Effect - Smooth line effect
        const trails = [];
        const maxTrails = 50;
        let lastTime = 0;
        
        function createCursorTrail(x, y, delay = 0) {
            setTimeout(() => {
                const trail = document.createElement('div');
                trail.className = 'cursor-trail';
                trail.style.left = x + 'px';
                trail.style.top = y + 'px';
                trail.style.opacity = '0.6';
                document.body.appendChild(trail);
                
                requestAnimationFrame(() => {
                    trail.style.opacity = '0';
                    trail.style.transform = 'translate(-50%, -50%) scale(0.2)';
                });
                
                setTimeout(() => {
                    if (trail.parentNode) {
                        trail.remove();
                    }
                }, 800);
                
                trails.push(trail);
                if (trails.length > maxTrails) {
                    const oldTrail = trails.shift();
                    if (oldTrail && oldTrail.parentNode) {
                        oldTrail.remove();
                    }
                }
            }, delay);
        }
        
        let lastX = 0;
        let lastY = 0;
        let mouseX = 0;
        let mouseY = 0;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            const now = Date.now();
            const timeSinceLastTrail = now - lastTime;
            
            if (timeSinceLastTrail > 8) {
                const distance = Math.sqrt(
                    Math.pow(mouseX - lastX, 2) + Math.pow(mouseY - lastY, 2)
                );
                
                if (distance > 2) {
                    createCursorTrail(mouseX, mouseY);
                    lastX = mouseX;
                    lastY = mouseY;
                    lastTime = now;
                }
            }
        });
    </script>
</body>
</html>

