<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - JNJ Website</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="chat.css">
    <link rel="stylesheet" href="animated-background.css">
    <link rel="stylesheet" href="secret-pages.css">
    <script src="page-transitions.js" defer></script>
    <script src="secret-pages.js" defer></script>
    <script src="animated-background.js" defer></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <!-- Firebase Config -->
    <script src="firebase-config.js"></script>
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Back to Home</a>
    
    <div class="chat-container" id="chatContainer">
        <header class="chat-header" id="chatHeader">
            <h1 id="chatTitle">JNJ Chat</h1>
            <p class="chat-subtitle">Junhu Choi ‚Ä¢ Jaxon Croskey ‚Ä¢ Nathan DeLuca</p>
            <button id="devStarButton" class="dev-star-button" style="display: none; position: absolute; top: 10px; right: 10px; background: rgba(255, 215, 0, 0.2); border: 2px solid #ffd700; border-radius: 50%; width: 50px; height: 50px; font-size: 28px; cursor: pointer; z-index: 1000; transition: all 0.2s; color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8); box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);" title="Become a Dev">‚≠ê</button>
            <div class="room-controls">
                <button id="createRoomButton" class="room-button" style="display: none;">Create Private Room</button>
                <button id="joinRoomButton" class="room-button" style="display: none;">Join Room</button>
                <button id="leaveRoomButton" class="room-button room-button-leave" style="display: none;">Leave Room</button>
                <div id="roomCodeDisplay" class="room-code-display" style="display: none;">
                    <span>Room: <strong id="currentRoomCodeDisplay"></strong></span>
                </div>
            </div>
        </header>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message welcome-message">
                <div class="message-content">
                    <p>Welcome to JNJ Chat! Start a conversation below.</p>
                </div>
            </div>
        </div>
        
        <div class="chat-input-container">
            <div class="user-name-container" id="userNameContainer" style="display: none;">
                <div class="current-name-display" id="currentNameDisplay">
                    <span>Chatting as: <strong id="currentNameText"></strong></span>
                    <a href="profile.html" class="change-name-button" style="text-decoration: none;">Edit Profile</a>
                </div>
            </div>
            <div class="input-wrapper">
                <button id="emojiButton" class="emoji-button" title="Add Emoji">üòÄ</button>
                <input 
                    type="text" 
                    id="messageInput" 
                    class="message-input" 
                    placeholder="Type a message..."
                    autocomplete="off"
                    disabled
                >
                <button id="gifButton" class="gif-button" title="Add GIF">GIF</button>
                <label for="imageInput" class="image-upload-button" title="Upload Image">
                    üì∑
                </label>
                <input 
                    type="file" 
                    id="imageInput" 
                    accept="image/*"
                    style="display: none;"
                    disabled
                >
                <button id="sendButton" class="send-button" disabled>Send</button>
            </div>
            <div id="imagePreview" class="image-preview" style="display: none;">
                <img id="previewImage" src="" alt="Preview">
                <button id="removeImageButton" class="remove-image-button">‚úï</button>
            </div>
            <div id="gifPreview" class="gif-preview" style="display: none;">
                <img id="previewGif" src="" alt="GIF Preview">
                <button id="removeGifButton" class="remove-image-button">‚úï</button>
            </div>
        </div>
    </div>

    <!-- Room Code Modal -->
    <div id="roomCodeModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Private Room Created!</h2>
            <p style="color: #b0b0b0; margin-bottom: 20px; text-align: center;">Share this code with your friends:</p>
            <div class="room-code-display-large">
                <span id="roomCodeDisplayText"></span>
                <button id="copyRoomCodeButton" class="copy-button" title="Copy code">üìã</button>
            </div>
            <button id="closeRoomCodeModal" class="modal-button" style="margin-top: 20px;">Close</button>
        </div>
    </div>

    <!-- Join Room Modal -->
    <div id="joinRoomModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Join Private Room</h2>
            <input type="text" id="roomCodeInput" placeholder="Enter room code..." maxlength="10">
            <div class="modal-buttons">
                <button id="confirmJoinButton" class="modal-button">Join</button>
                <button id="cancelJoinButton" class="modal-button modal-button-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Emoji Picker Modal -->
    <div id="emojiPickerModal" class="modal emoji-picker-modal" style="display: none;">
        <div class="modal-content emoji-picker-content">
            <h2>Choose an Emoji</h2>
            <div class="emoji-grid" id="emojiGrid"></div>
            <button id="closeEmojiPicker" class="modal-button" style="margin-top: 15px;">Close</button>
        </div>
    </div>

    <!-- GIF Picker Modal -->
    <div id="gifPickerModal" class="modal gif-picker-modal" style="display: none;">
        <div class="modal-content gif-picker-content">
            <h2>Search GIFs</h2>
            <div class="gif-search-wrapper">
                <input type="text" id="gifSearchInput" class="gif-search-input" placeholder="Search for GIFs...">
                <button id="gifSearchButton" class="gif-search-button">Search</button>
            </div>
            <div class="gif-grid" id="gifGrid">
                <div class="gif-loading">Loading trending GIFs...</div>
            </div>
            <button id="closeGifPicker" class="modal-button" style="margin-top: 15px;">Close</button>
        </div>
    </div>

    <!-- Dev Password Modal -->
    <div id="devPasswordModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <h2>‚≠ê Dev Access</h2>
            <p style="margin-bottom: 20px; opacity: 0.8;">Enter the dev password to unlock moderation tools:</p>
            <input type="password" id="devPasswordInput" class="message-input" placeholder="Enter password..." style="width: 100%; margin-bottom: 15px; padding: 12px;">
            <div style="display: flex; gap: 10px;">
                <button id="submitDevPassword" class="send-button" style="flex: 1;">Submit</button>
                <button id="cancelDevPassword" class="room-button" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Message Actions Modal (for dev users) -->
    <div id="messageActionsModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 400px;">
            <h2>Message Actions</h2>
            <p id="messageActionsUser" style="margin-bottom: 20px; opacity: 0.8;"></p>
            <button id="deleteMessageBtn" class="send-button" style="width: 100%; margin-bottom: 10px; background: #dc2626;">Delete Message</button>
            <button id="banUserBtn" class="send-button" style="width: 100%; margin-bottom: 10px; background: #f59e0b;">Ban User</button>
            <button id="cancelMessageActions" class="room-button" style="width: 100%;">Cancel</button>
        </div>
    </div>

    <!-- Ban Duration Modal -->
    <div id="banDurationModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 400px;">
            <h2>Ban User</h2>
            <p id="banUserInfo" style="margin-bottom: 20px; opacity: 0.8;"></p>
            <label style="display: block; margin-bottom: 10px;">Ban Duration:</label>
            <select id="banDurationSelect" class="message-input" style="width: 100%; margin-bottom: 15px; padding: 12px;">
                <option value="5">5 minutes</option>
                <option value="15">15 minutes</option>
                <option value="30">30 minutes</option>
                <option value="60">1 hour</option>
                <option value="1440">1 day</option>
                <option value="10080">1 week</option>
                <option value="43200">1 month</option>
            </select>
            <div style="display: flex; gap: 10px;">
                <button id="confirmBanBtn" class="send-button" style="flex: 1; background: #dc2626;">Confirm Ban</button>
                <button id="cancelBanBtn" class="room-button" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize Firebase
        let db = null;
        let messagesUnsubscribe = null;
        
        try {
            if (typeof firebaseConfig !== 'undefined') {
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                window.db = db; // Expose db to window for profile page access
                console.log('Firebase connected successfully!');
            } else {
                console.warn('Firebase config not found. Using localStorage fallback.');
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            console.warn('Falling back to localStorage.');
        }
        
        // Private Room Variables
        let currentRoomCode = null;

        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const currentNameDisplay = document.getElementById('currentNameDisplay');
        const currentNameText = document.getElementById('currentNameText');
        const userNameContainer = document.getElementById('userNameContainer');
        
        // Dev star and modals
        const devStarButton = document.getElementById('devStarButton');
        const devPasswordModal = document.getElementById('devPasswordModal');
        const devPasswordInput = document.getElementById('devPasswordInput');
        const submitDevPassword = document.getElementById('submitDevPassword');
        const cancelDevPassword = document.getElementById('cancelDevPassword');
        const messageActionsModal = document.getElementById('messageActionsModal');
        const deleteMessageBtn = document.getElementById('deleteMessageBtn');
        const banUserBtn = document.getElementById('banUserBtn');
        const cancelMessageActions = document.getElementById('cancelMessageActions');
        const banDurationModal = document.getElementById('banDurationModal');
        const banDurationSelect = document.getElementById('banDurationSelect');
        const confirmBanBtn = document.getElementById('confirmBanBtn');
        const cancelBanBtn = document.getElementById('cancelBanBtn');
        const banUserInfo = document.getElementById('banUserInfo');
        const messageActionsUser = document.getElementById('messageActionsUser');
        
        let selectedMessageForAction = null;
        let selectedUserForBan = null;
        let selectedUserIdForBan = null;
        const DEV_PASSWORD = 'testtypetexthereSACbzn1234567890=-09090909009mt9-9=0DevBlockPasswordistohardtoguesswhywhywhy???><><2323tteessttlongpassword75shdsdhidshueew8iugjhlkghdffposdiavkhjxdbfkjs;go;sdpbtspodgp;dsg(-_-)';
        
        // Room UI elements
        const createRoomButton = document.getElementById('createRoomButton');
        const joinRoomButton = document.getElementById('joinRoomButton');
        const leaveRoomButton = document.getElementById('leaveRoomButton');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const currentRoomCodeDisplay = document.getElementById('currentRoomCodeDisplay');
        const roomCodeModal = document.getElementById('roomCodeModal');
        const roomCodeDisplayText = document.getElementById('roomCodeDisplayText');
        const copyRoomCodeButton = document.getElementById('copyRoomCodeButton');
        const closeRoomCodeModal = document.getElementById('closeRoomCodeModal');
        const joinRoomModal = document.getElementById('joinRoomModal');
        const roomCodeInput = document.getElementById('roomCodeInput');
        const confirmJoinButton = document.getElementById('confirmJoinButton');
        const cancelJoinButton = document.getElementById('cancelJoinButton');
        
        // Emoji and GIF picker elements
        const emojiButton = document.getElementById('emojiButton');
        const gifButton = document.getElementById('gifButton');
        const emojiPickerModal = document.getElementById('emojiPickerModal');
        const gifPickerModal = document.getElementById('gifPickerModal');
        const emojiGrid = document.getElementById('emojiGrid');
        const gifGrid = document.getElementById('gifGrid');
        const gifSearchInput = document.getElementById('gifSearchInput');
        const gifSearchButton = document.getElementById('gifSearchButton');
        const closeEmojiPicker = document.getElementById('closeEmojiPicker');
        const closeGifPicker = document.getElementById('closeGifPicker');
        
        // Giphy API key
        const GIPHY_API_KEY = 'Dhphjb15RHAVVMl43LwS3V73cS3oYj9J';

        let currentUserName = '';
        let loadedMessageIds = new Set(); // Track loaded messages to prevent duplicates
        const MAX_VISIBLE_MESSAGES = 35; // Maximum number of messages to display
        let isInitialLoad = true; // Track if this is the first load
        let selectedImage = null; // Store selected image as base64

        // Load saved name from profile only
        function loadUserName() {
            // Only check profile - no fallback to chat name input
            const profileData = localStorage.getItem('jnjUserProfile');
            if (profileData) {
                try {
                    const profile = JSON.parse(profileData);
                    
                    // Generate userId for old profiles that don't have one
                    if (!profile.userId) {
                        // Generate a unique user ID (same function as in profile.html)
                        function generateUserId() {
                            return 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15);
                        }
                        profile.userId = generateUserId();
                        localStorage.setItem('jnjUserProfile', JSON.stringify(profile));
                        console.log('Generated userId for old profile in chat:', profile.userId);
                    }
                    
                    // Get userId for ban checking
                    const userId = profile.userId || null;
                    // Use username if available, otherwise fallback to displayName
                    if (profile.username && profile.username.trim() !== '') {
                        currentUserName = profile.username.trim();
                        showNameDisplay();
                        // Check ban status before enabling (use userId if available)
                        if (userId && isUserBannedById(userId)) {
                            disableChatBanned();
                        } else if (isUserBanned(currentUserName)) {
                            disableChatBanned();
                        } else {
                            enableChat();
                        }
                        return;
                    } else if (profile.displayName && profile.displayName.trim() !== '') {
                        currentUserName = profile.displayName.trim();
                        showNameDisplay();
                        // Check ban status before enabling (use userId if available)
                        if (userId && isUserBannedById(userId)) {
                            disableChatBanned();
                        } else if (isUserBanned(currentUserName)) {
                            disableChatBanned();
                        } else {
                            enableChat();
                        }
                        return;
                    }
                } catch (e) {
                    console.error('Error loading profile:', e);
                }
            }
            
            // No profile - show message to create profile
            showNoProfileMessage();
            disableChat();
        }

        // Show current name display
        function showNameDisplay() {
            if (userNameContainer) {
                userNameContainer.style.display = 'block';
            }
            if (currentNameDisplay) {
                currentNameDisplay.style.display = 'flex';
            }
            if (currentNameText) {
                currentNameText.textContent = currentUserName;
            }
        }
        
        // Show message when no profile exists
        function showNoProfileMessage() {
            if (userNameContainer) {
                userNameContainer.style.display = 'block';
            }
            if (currentNameDisplay) {
                currentNameDisplay.style.display = 'flex';
            }
            if (currentNameText) {
                currentNameText.innerHTML = '<a href="profile.html" style="color: #4a9eff; text-decoration: underline;">Create a profile</a> to start chatting';
            }
        }

        // Enable chat input
        function enableChat() {
            // COMPREHENSIVE BAN CHECK - check everything before enabling
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (profileData) {
                    const profile = JSON.parse(profileData);
                    const checkUserId = profile.userId || null;
                    const checkUsername = profile.username || profile.displayName || currentUserName || '';
                    const allBans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                    const now = Date.now();
                    
                    // Check every ban
                    for (const banKey in allBans) {
                        const ban = allBans[banKey];
                        if (ban.bannedUntil <= now) continue;
                        
                        // Check userId match
                        if (checkUserId && (banKey === checkUserId || ban.bannedUserId === checkUserId)) {
                            console.log('üö´ enableChat: User banned by userId - disabling');
                            disableChatBanned();
                            return;
                        }
                        
                        // Check username match
                        const bannedUsername = ban.bannedUsername || banKey;
                        if (checkUsername && checkUsername.trim().toLowerCase() === bannedUsername.trim().toLowerCase()) {
                            console.log('üö´ enableChat: User banned by username - disabling');
                            disableChatBanned();
                            return;
                        }
                        
                        // Check banKey match
                        if (checkUsername && banKey.trim().toLowerCase() === checkUsername.trim().toLowerCase()) {
                            console.log('üö´ enableChat: User banned by banKey - disabling');
                            disableChatBanned();
                            return;
                        }
                    }
                }
            } catch (e) {
                console.error('Error in enableChat ban check:', e);
            }
            
            messageInput.disabled = false;
            messageInput.readOnly = false;
            sendButton.disabled = false;
            document.getElementById('imageInput').disabled = false;
            emojiButton.disabled = false;
            gifButton.disabled = false;
            messageInput.placeholder = 'Type a message...';
        }
        
        // Disable chat input because user is banned
        function disableChatBanned() {
            messageInput.disabled = true;
            messageInput.readOnly = true;
            sendButton.disabled = true;
            document.getElementById('imageInput').disabled = true;
            emojiButton.disabled = true;
            gifButton.disabled = true;
            
            // Clear any existing text
            messageInput.value = '';
            
            // Get ban info for message
            try {
                const bans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                const ban = bans[currentUserName];
                if (ban) {
                    const banUntil = new Date(ban.bannedUntil);
                    const timeLeft = Math.ceil((ban.bannedUntil - Date.now()) / (1000 * 60)); // minutes
                    if (timeLeft > 60) {
                        const hours = Math.floor(timeLeft / 60);
                        const mins = timeLeft % 60;
                        messageInput.placeholder = `You are banned. Time remaining: ${hours}h ${mins}m`;
                    } else {
                        messageInput.placeholder = `You are banned. Time remaining: ${timeLeft} minutes`;
                    }
                } else {
                    messageInput.placeholder = 'You are banned from chatting.';
                }
            } catch (e) {
                messageInput.placeholder = 'You are banned from chatting.';
            }
        }

        // Disable chat input
        function disableChat() {
            messageInput.disabled = true;
            sendButton.disabled = true;
            document.getElementById('imageInput').disabled = true;
            emojiButton.disabled = true;
            gifButton.disabled = true;
            messageInput.placeholder = 'Enter your name above to start chatting...';
        }

        // Update room UI based on current room state
        function updateRoomUI() {
            if (currentRoomCode) {
                // In a room - show leave button and room code
                createRoomButton.style.display = 'none';
                joinRoomButton.style.display = 'none';
                leaveRoomButton.style.display = 'block';
                roomCodeDisplay.style.display = 'flex';
                currentRoomCodeDisplay.textContent = currentRoomCode;
            } else {
                // Not in a room - show create/join buttons
                createRoomButton.style.display = 'block';
                joinRoomButton.style.display = 'block';
                leaveRoomButton.style.display = 'none';
                roomCodeDisplay.style.display = 'none';
            }
        }
        
        // Load messages from Firestore or localStorage fallback
        function loadMessages() {
            // Check if user has a room code
            const savedRoom = localStorage.getItem('jjnChatRoomCode');
            if (savedRoom) {
                // Validate the saved room code
                checkRoomValidity(savedRoom).then((isValid) => {
                    if (!isValid) {
                        // Room expired or doesn't exist, clear it
                        currentRoomCode = null;
                        localStorage.removeItem('jjnChatRoomCode');
                        updateRoomUI();
                    } else {
                        currentRoomCode = savedRoom;
                    }
                    
                    // Update UI based on room state
                    updateRoomUI();
                    
                    // Check if dev chat and apply styling
                    checkDevChatOnLoad();
                    
                    // Update welcome message
                    const welcomeMsg = chatMessages.querySelector('.welcome-message');
                    if (welcomeMsg) {
                        if (currentRoomCode === 'devchat') {
                            welcomeMsg.classList.add('dev-welcome');
                            welcomeMsg.querySelector('.message-content').innerHTML = '<p>üîß Welcome to Dev Chat Room!</p><p style="margin-top: 10px; font-size: 14px; opacity: 0.8;">This is a secret developer chat room.</p>';
                        } else if (currentRoomCode) {
                            welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to Private Room ' + currentRoomCode + '!';
                        } else {
                            welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to JNJ Chat! Start a conversation below.';
                        }
                    }
                    
                    // Reload username from profile to ensure it's up to date
                    loadUserName();
                    
                    // Load and sync bans from Firestore
                    loadBansFromFirestore().then(() => {
                        // Set up real-time listener for bans after username is loaded
                        setupBanListener();
                    });
                    
                    // Load messages
                    if (db) {
                        // Use Firestore with real-time updates
                        loadMessagesFromFirestore(currentRoomCode);
                    } else {
                        // Fallback to localStorage
                        const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                        // Filter by room code if in a room
                        let filteredMessages = messages;
                        if (currentRoomCode) {
                            filteredMessages = messages.filter(msg => msg.roomCode === currentRoomCode);
                        } else {
                            filteredMessages = messages.filter(msg => !msg.roomCode);
                        }
                        // Only show the most recent messages
                        const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                        recentMessages.forEach(msg => {
                            addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id, msg.userId);
                        });
                        scrollToBottom();
                    }
                }).catch((error) => {
                    console.error('Error validating saved room:', error);
                    // On error, default to public chat
                    currentRoomCode = null;
                    localStorage.removeItem('jjnChatRoomCode');
                    updateRoomUI();
                    
                    const welcomeMsg = chatMessages.querySelector('.welcome-message');
                    if (welcomeMsg) {
                        welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to JNJ Chat! Start a conversation below.';
                    }
                    
                    if (db) {
                        loadMessagesFromFirestore(null);
                    } else {
                        const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                        const filteredMessages = messages.filter(msg => !msg.roomCode);
                        const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                        recentMessages.forEach(msg => {
                            addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id, msg.userId);
                        });
                        scrollToBottom();
                    }
                });
            } else {
                // No saved room, load public chat
                currentRoomCode = null;
                updateRoomUI();
                
                const welcomeMsg = chatMessages.querySelector('.welcome-message');
                if (welcomeMsg) {
                    welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to JNJ Chat! Start a conversation below.';
                }
                
                if (db) {
                    loadMessagesFromFirestore(null);
                } else {
                    const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                    const filteredMessages = messages.filter(msg => !msg.roomCode);
                    const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                    recentMessages.forEach(msg => {
                        addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, null, null, msg.id, msg.userId);
                    });
                    scrollToBottom();
                }
            }
        }

        // Load messages from Firestore with real-time listener
        function loadMessagesFromFirestore(roomCode = null) {
            // Unsubscribe from previous listener
            if (messagesUnsubscribe) {
                messagesUnsubscribe();
            }
            
            // Clear existing messages (except welcome message) before loading
            const existingMessages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            existingMessages.forEach(msg => msg.remove());
            loadedMessageIds.clear();
            isInitialLoad = true;
            
            // Determine which collection to use
            const collection = roomCode ? 'roomMessages' : 'messages';
            let query = db.collection(collection);
            
            // If in a room, filter by room code first
            // Note: We don't use orderBy here to avoid requiring a composite index
            // We'll sort in memory instead
            if (roomCode) {
                query = query.where('roomCode', '==', roomCode);
            } else {
                query = query.orderBy('timestamp', 'desc').limit(MAX_VISIBLE_MESSAGES);
            }
            
            // Set up real-time listener that gets all current messages and then listens for changes
            messagesUnsubscribe = query.onSnapshot((querySnapshot) => {
                    // On initial load, clear and reload all messages
                    if (isInitialLoad) {
                        const messages = [];
                        querySnapshot.forEach((doc) => {
                            const data = doc.data();
                            // Double-check room code match for safety
                            if (roomCode) {
                                // Only include messages with matching room code
                                if (data.roomCode === roomCode) {
                                    messages.push({
                                        id: doc.id,
                                        user: data.user,
                                        message: data.message,
                                        timestamp: data.timestamp,
                                        image: data.image || null,
                                        gif: data.gif || null,
                                        avatar: data.avatar || null,
                                        avatarImage: data.avatarImage || null
                                    });
                                }
                            } else {
                                // Only include messages without roomCode in public chat
                                if (!data.roomCode) {
                                    messages.push({
                                        id: doc.id,
                                        user: data.user,
                                        message: data.message,
                                        timestamp: data.timestamp,
                                        image: data.image || null,
                                        gif: data.gif || null,
                                        avatar: data.avatar || null,
                                        avatarImage: data.avatarImage || null
                                    });
                                }
                            }
                        });
                        
                        // Sort by timestamp descending (newest first), then take most recent
                        messages.sort((a, b) => b.timestamp - a.timestamp);
                        const recentMessages = messages.slice(0, MAX_VISIBLE_MESSAGES);
                        
                        // Display messages in reverse order (oldest first)
                        recentMessages.reverse().forEach(msg => {
                            if (!loadedMessageIds.has(msg.id)) {
                                console.log('Loading message from initial load:', { user: msg.user, hasGif: !!msg.gif, gifUrl: msg.gif });
                                addMessageToChat(msg.user, msg.message || '', msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id, msg.userId);
                                loadedMessageIds.add(msg.id);
                            }
                        });
                        scrollToBottom();
                        isInitialLoad = false;
                        
                        // Setup message click handlers for dev users
                        setupMessageClickHandlers();
                    } else {
                        // After initial load, only process new changes
                        querySnapshot.docChanges().forEach((change) => {
                            if (change.type === 'added' && !loadedMessageIds.has(change.doc.id)) {
                                const data = change.doc.data();
                                console.log('New message received:', { 
                                    user: data.user, 
                                    message: data.message,
                                    hasImage: !!data.image, 
                                    hasGif: !!data.gif, 
                                    gifUrl: data.gif,
                                    fullData: data
                                });
                                // Double-check room code match
                                if (roomCode) {
                                    if (data.roomCode === roomCode) {
                                        addMessageToChat(data.user, data.message || '', data.timestamp, false, data.image || null, data.gif || null, data.avatar, data.avatarImage, change.doc.id, data.userId);
                                        loadedMessageIds.add(change.doc.id);
                                    }
                                } else {
                                    // Only show messages without roomCode in public chat
                                    if (!data.roomCode) {
                                        addMessageToChat(data.user, data.message || '', data.timestamp, false, data.image || null, data.gif || null, data.avatar, data.avatarImage, change.doc.id, data.userId);
                                        loadedMessageIds.add(change.doc.id);
                                    }
                                }
                            } else if (change.type === 'removed') {
                                // Message was deleted - remove it from DOM
                                const messageId = change.doc.id;
                                const messageElement = chatMessages.querySelector(`[data-message-id="${messageId}"]`);
                                if (messageElement) {
                                    console.log('Removing deleted message from DOM:', messageId);
                                    messageElement.remove();
                                    loadedMessageIds.delete(messageId);
                                }
                            }
                        });
                        scrollToBottom();
                    }
                }, (error) => {
                    console.error('Error in real-time listener:', error);
                    console.error('Error code:', error.code, 'Error message:', error.message);
                    
                    // If it's an index error, try alternative query
                    if (error.code === 'failed-precondition' && roomCode) {
                        console.log('Index missing, trying alternative query...');
                        // Try getting all room messages and filtering in memory
                        db.collection('roomMessages')
                            .where('roomCode', '==', roomCode)
                            .get()
                            .then((querySnapshot) => {
                                const messages = [];
                                querySnapshot.forEach((doc) => {
                                    const data = doc.data();
                                    if (data.roomCode === roomCode) {
                                        messages.push({
                                            id: doc.id,
                                            user: data.user,
                                            message: data.message,
                                            timestamp: data.timestamp,
                                            image: data.image || null,
                                            gif: data.gif || null
                                        });
                                    }
                                });
                                // Sort by timestamp descending
                                messages.sort((a, b) => b.timestamp - a.timestamp);
                                // Take only the most recent
                                const recentMessages = messages.slice(0, MAX_VISIBLE_MESSAGES);
                                // Reverse to show oldest first
                                recentMessages.reverse();
                                recentMessages.forEach(msg => {
                                    if (!loadedMessageIds.has(msg.id)) {
                                        addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id, msg.userId);
                                        loadedMessageIds.add(msg.id);
                                    }
                                });
                                scrollToBottom();
                                
                                // Set up a simpler listener without orderBy
                                messagesUnsubscribe = db.collection('roomMessages')
                                    .where('roomCode', '==', roomCode)
                                    .onSnapshot((snapshot) => {
                                        snapshot.docChanges().forEach((change) => {
                                            if (change.type === 'added' && !loadedMessageIds.has(change.doc.id)) {
                                                const data = change.doc.data();
                                                console.log('Fallback listener - New message:', { user: data.user, hasGif: !!data.gif, gifUrl: data.gif, fullData: data });
                                                if (data.roomCode === roomCode) {
                                                    addMessageToChat(data.user, data.message || '', data.timestamp, false, data.image || null, data.gif || null, data.avatar, data.avatarImage, change.doc.id, data.userId);
                                                    loadedMessageIds.add(change.doc.id);
                                                }
                                            } else if (change.type === 'removed') {
                                                // Message was deleted - remove it from DOM
                                                const messageId = change.doc.id;
                                                const messageElement = chatMessages.querySelector(`[data-message-id="${messageId}"]`);
                                                if (messageElement) {
                                                    console.log('Fallback listener - Removing deleted message from DOM:', messageId);
                                                    messageElement.remove();
                                                    loadedMessageIds.delete(messageId);
                                                }
                                            }
                                        });
                                        scrollToBottom();
                                    });
                            })
                            .catch((fallbackError) => {
                                console.error('Fallback query also failed:', fallbackError);
                                // Final fallback to localStorage
                                const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                                let filteredMessages = messages.filter(msg => msg.roomCode === roomCode);
                                const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                                recentMessages.forEach(msg => {
                                    addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image || null, msg.gif || null, msg.avatar, msg.avatarImage, msg.id);
                                });
                                scrollToBottom();
                            });
                        return;
                    }
                    
                    // Fallback to localStorage
                    const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                    // Filter by room code if in a room
                    let filteredMessages = messages;
                    if (roomCode) {
                        filteredMessages = messages.filter(msg => msg.roomCode === roomCode);
                    } else {
                        filteredMessages = messages.filter(msg => !msg.roomCode);
                    }
                    // Only show the most recent messages
                    const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                    recentMessages.forEach(msg => {
                        addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image || null, msg.gif || null, msg.avatar, msg.avatarImage, msg.id);
                    });
                    scrollToBottom();
                });
        }

        // Save message to Firestore or localStorage fallback
        function saveMessage(user, message, timestamp, imageData = null, gifData = null, avatar = null, avatarImage = null, userId = null) {
            const messageData = {
                user: user,
                message: message,
                timestamp: timestamp
            };
            
            // Add userId if provided
            if (userId) {
                messageData.userId = userId;
            }
            
            if (imageData) {
                messageData.image = imageData;
            }
            
            if (gifData) {
                messageData.gif = gifData;
            }
            
            // Save avatar with message
            if (avatarImage) {
                messageData.avatarImage = avatarImage;
            } else if (avatar) {
                messageData.avatar = avatar;
            }
            
            // Log what we're saving
            console.log('Saving message to Firestore:', { 
                user: user, 
                hasImage: !!imageData, 
                hasGif: !!gifData, 
                hasAvatar: !!avatar, 
                hasAvatarImage: !!avatarImage,
                fullMessageData: messageData 
            });
            
            // Add room code if in a private room
            if (currentRoomCode) {
                messageData.roomCode = currentRoomCode;
            }
            
            if (db) {
                // Save to Firestore - use roomMessages collection if in a room
                const collection = currentRoomCode ? 'roomMessages' : 'messages';
                
                // Log exactly what we're sending to Firestore
                console.log('About to save to Firestore:', {
                    collection: collection,
                    messageDataKeys: Object.keys(messageData),
                    hasAvatar: 'avatar' in messageData,
                    hasAvatarImage: 'avatarImage' in messageData,
                    avatarValue: messageData.avatar,
                    avatarImageLength: messageData.avatarImage ? messageData.avatarImage.length : 0,
                    fullMessageData: messageData
                });
                
                db.collection(collection).add(messageData)
                .then((docRef) => {
                    console.log('Message saved successfully to', collection, 'with ID:', docRef.id);
                    // Verify what was actually saved by reading it back
                    docRef.get().then((doc) => {
                        const savedData = doc.data();
                        console.log('Verifying saved data:', {
                            hasAvatar: 'avatar' in savedData,
                            hasAvatarImage: 'avatarImage' in savedData,
                            savedKeys: Object.keys(savedData)
                        });
                    });
                    // Update the message element with the actual document ID
                    const messageElement = chatMessages.querySelector(`[data-message-id="temp-${timestamp}"]`);
                    if (messageElement) {
                        messageElement.setAttribute('data-message-id', docRef.id);
                    }
                })
                .catch((error) => {
                    console.error('Error saving message to Firestore:', error);
                    console.error('Error details:', error.code, error.message);
                    console.error('Message data that failed:', messageData);
                    // Fallback to localStorage
                    saveMessageToLocalStorage(user, message, timestamp, imageData, gifData, avatar, avatarImage, userId);
                });
            } else {
                // Fallback to localStorage
                saveMessageToLocalStorage(user, message, timestamp, imageData, gifData, avatar, avatarImage, userId);
            }
        }

        // Fallback: Save messages to localStorage
        function saveMessageToLocalStorage(user, message, timestamp, imageData = null, gifData = null, avatar = null, avatarImage = null, userId = null) {
            const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
            const messageObj = { user, message, timestamp };
            if (imageData) {
                messageObj.image = imageData;
            }
            if (gifData) {
                messageObj.gif = gifData;
            }
            // Save avatar with message
            if (avatarImage) {
                messageObj.avatarImage = avatarImage;
            } else if (avatar) {
                messageObj.avatar = avatar;
            }
            // Save userId if provided
            if (userId) {
                messageObj.userId = userId;
            }
            // Add room code if in a private room
            if (currentRoomCode) {
                messageObj.roomCode = currentRoomCode;
            }
            messages.push(messageObj);
            // Keep only last 100 messages
            if (messages.length > 100) {
                messages.shift();
            }
            localStorage.setItem('jjnChatMessages', JSON.stringify(messages));
        }

        // Add message to chat display
        function addMessageToChat(user, message, timestamp, shouldSave = true, imageData = null, gifData = null, avatar = null, avatarImage = null, messageId = null, userId = null) {
            // Remove welcome message if it exists
            const welcomeMsg = chatMessages.querySelector('.welcome-message');
            if (welcomeMsg) {
                welcomeMsg.remove();
            }

            if (shouldSave) {
                saveMessage(user, message, timestamp, imageData, gifData);
            }

            // Check if message already exists (prevent duplicates)
            const existingMessages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            for (let msg of existingMessages) {
                const msgTime = msg.getAttribute('data-timestamp');
                const msgUser = msg.querySelector('.message-user').textContent;
                const msgContent = msg.querySelector('.message-content p')?.textContent || '';
                const msgImage = msg.querySelector('.message-image');
                const msgGif = msg.querySelector('.message-gif');
                const hasImage = msgImage !== null;
                const hasGif = msgGif !== null;
                // Check if this is the same message (same timestamp, user, content, and media)
                if (msgTime == timestamp && msgUser === user && msgContent === message) {
                    // If both have the same media state (both have image, both have gif, both have neither)
                    if (hasImage === !!imageData && hasGif === !!gifData) {
                        return; // Message already exists, don't add duplicate
                    }
                }
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.setAttribute('data-timestamp', timestamp);
            // Add userId as data attribute for banning
            if (userId) {
                messageDiv.setAttribute('data-user-id', userId);
            }
            // Add message ID for tracking
            if (messageId) {
                // Use provided message ID (from Firestore)
                messageDiv.setAttribute('data-message-id', messageId);
            } else if (shouldSave && db) {
                // We'll set this after saving, but for now use timestamp as ID
                messageDiv.setAttribute('data-message-id', 'temp-' + timestamp);
            }
            
            const time = new Date(timestamp);
            const timeString = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            let imageHtml = '';
            if (imageData) {
                const imageId = 'img-' + timestamp;
                imageHtml = `<div class="message-image"><img id="${imageId}" src="${imageData}" alt="Uploaded image" class="chat-image"></div>`;
            }
            
            let gifHtml = '';
            if (gifData) {
                const gifId = 'gif-' + timestamp;
                console.log('Displaying GIF:', { gifUrl: gifData, timestamp: timestamp, user: user });
                gifHtml = `<div class="message-gif"><img id="${gifId}" src="${gifData}" alt="GIF" class="chat-gif" onerror="console.error('GIF failed to load:', this.src)"></div>`;
            } else {
                console.log('No GIF data to display for message:', { user: user, timestamp: timestamp });
            }
            
            // Censor the message before displaying (in case it wasn't censored when saved)
            let censoredMessage = censorMessage(message);
            
            // Convert emoji codes in message to actual emojis (basic support)
            let messageHtml = censoredMessage ? escapeHtml(censoredMessage) : '';
            // Emojis are already Unicode, so they should display fine
            
            // Use avatar from message data (saved with message), or fallback to profile if it's the current user
            let userAvatar = avatar || 'üë§';
            let userAvatarImage = avatarImage || null;
            let displayUsername = user; // Default to the user value
            
            // If no avatar in message data, check if it's the current user and use their profile
            if (!avatar && !avatarImage) {
                try {
                    const profileData = localStorage.getItem('jnjUserProfile');
                    if (profileData) {
                        const profile = JSON.parse(profileData);
                        // Check if this message is from the current user (match by username or displayName)
                        if (user === profile.username || user === profile.displayName) {
                            // Use username for display if available
                            if (profile.username && profile.username.trim() !== '') {
                                displayUsername = profile.username.trim();
                            }
                            // Get avatar from profile
                            if (profile.avatarImage) {
                                userAvatarImage = profile.avatarImage;
                            } else if (profile.avatar) {
                                userAvatar = profile.avatar;
                            }
                        }
                    }
                } catch (e) {
                    // Ignore errors
                }
            }
            
            // Create avatar HTML
            let avatarHtml = '';
            if (userAvatarImage) {
                // Base64 data URLs are safe to use directly (they come from profile or message data)
                avatarHtml = `<img src="${userAvatarImage}" alt="Avatar" class="message-avatar-image" style="width: 32px; height: 32px; border-radius: 50%; margin-right: 8px; object-fit: cover; border: 2px solid rgba(255, 255, 255, 0.2);">`;
            } else {
                // Emoji is safe to use directly
                avatarHtml = `<span class="message-avatar" style="font-size: 20px; margin-right: 8px;">${userAvatar}</span>`;
            }
            
            messageDiv.innerHTML = `
                <div class="message-header" style="display: flex; align-items: center; gap: 8px;">
                    ${avatarHtml}
                    <span class="message-user">${escapeHtml(displayUsername)}</span>
                    <span class="message-time" style="margin-left: auto;">${timeString}</span>
                </div>
                <div class="message-content">
                    ${imageHtml}
                    ${gifHtml}
                    ${messageHtml ? `<p>${messageHtml}</p>` : (imageHtml || gifHtml ? '' : '<p></p>')}
                </div>
            `;
            
            // Add click handler for image expansion
            if (imageData) {
                const imageId = 'img-' + timestamp;
                const img = messageDiv.querySelector('#' + imageId);
                if (img) {
                    img.addEventListener('click', function() {
                        expandImage(this);
                    });
                }
            }
            
            // Add click handler for GIF expansion
            if (gifData) {
                const gifId = 'gif-' + timestamp;
                const gif = messageDiv.querySelector('#' + gifId);
                if (gif) {
                    gif.addEventListener('click', function() {
                        expandImage(this);
                    });
                }
            }
            
            // Insert message in correct chronological order
            const allMessages = Array.from(chatMessages.querySelectorAll('.message:not(.welcome-message)'));
            let inserted = false;
            for (let i = 0; i < allMessages.length; i++) {
                const msgTimestamp = parseInt(allMessages[i].getAttribute('data-timestamp') || '0');
                if (timestamp < msgTimestamp) {
                    chatMessages.insertBefore(messageDiv, allMessages[i]);
                    inserted = true;
                    break;
                }
            }
            if (!inserted) {
                chatMessages.appendChild(messageDiv);
            }
            
            // Setup click handlers for dev users
            if (isDev()) {
                messageDiv.addEventListener('click', handleMessageClick);
                messageDiv.style.cursor = 'pointer';
                messageDiv.title = 'Click to moderate (Dev only)';
            }
            
            // Remove old messages if we exceed the limit
            limitVisibleMessages();
            
            scrollToBottom();
        }

        // Limit visible messages to MAX_VISIBLE_MESSAGES
        function limitVisibleMessages() {
            const allMessages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            if (allMessages.length > MAX_VISIBLE_MESSAGES) {
                // Remove the oldest messages (first ones in the list)
                const messagesToRemove = allMessages.length - MAX_VISIBLE_MESSAGES;
                for (let i = 0; i < messagesToRemove; i++) {
                    allMessages[i].remove();
                }
            }
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Scroll to bottom of chat
        function scrollToBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // Update all displayed messages with new username
        function updateChatMessagesUsername(oldUsername, oldDisplayName, newUsername) {
            // Get current user's profile to identify their messages
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (!profileData) return;
                
                const profile = JSON.parse(profileData);
                const currentUsername = profile.username || profile.displayName;
                
                // Update all message elements in the chat
                const messageElements = chatMessages.querySelectorAll('.message');
                messageElements.forEach(msgEl => {
                    const userSpan = msgEl.querySelector('.message-user');
                    if (userSpan) {
                        const currentText = userSpan.textContent.trim();
                        // Check if this message is from the current user
                        if (currentText === oldUsername || currentText === oldDisplayName) {
                            userSpan.textContent = newUsername;
                        }
                    }
                });
                
                // Also update currentUserName if it matches
                if (currentUserName === oldUsername || currentUserName === oldDisplayName) {
                    currentUserName = newUsername;
                    if (currentNameText) {
                        currentNameText.textContent = newUsername;
                    }
                }
            } catch (e) {
                console.error('Error updating chat messages:', e);
            }
        }
        
        // Update Firestore messages with new username
        function updateFirestoreMessagesUsername(oldUsername, oldDisplayName, newUsername) {
            if (!db) return;
            
            // Update public messages
            updateFirestoreCollection('messages', oldUsername, oldDisplayName, newUsername);
            // Update room messages
            updateFirestoreCollection('roomMessages', oldUsername, oldDisplayName, newUsername);
        }
        
        function updateFirestoreCollection(collectionName, oldUsername, oldDisplayName, newUsername) {
            if (!db) return;
            
            const collection = db.collection(collectionName);
            
            // Update messages with old username
            if (oldUsername) {
                collection.where('user', '==', oldUsername).get()
                    .then(querySnapshot => {
                        if (querySnapshot.empty) return;
                        const batch = db.batch();
                        let updateCount = 0;
                        querySnapshot.forEach(doc => {
                            batch.update(doc.ref, { user: newUsername });
                            updateCount++;
                        });
                        if (updateCount > 0) {
                            return batch.commit().then(() => {
                                console.log(`Updated ${updateCount} ${collectionName} messages from ${oldUsername} to ${newUsername}`);
                            });
                        }
                    })
                    .catch(error => {
                        console.error(`Error updating ${collectionName} messages:`, error);
                    });
            }
            
            // Update messages with old displayName (if different from username)
            if (oldDisplayName && oldDisplayName !== oldUsername) {
                collection.where('user', '==', oldDisplayName).get()
                    .then(querySnapshot => {
                        if (querySnapshot.empty) return;
                        const batch2 = db.batch();
                        let updateCount2 = 0;
                        querySnapshot.forEach(doc => {
                            batch2.update(doc.ref, { user: newUsername });
                            updateCount2++;
                        });
                        if (updateCount2 > 0) {
                            return batch2.commit().then(() => {
                                console.log(`Updated ${updateCount2} ${collectionName} messages from ${oldDisplayName} to ${newUsername}`);
                            });
                        }
                    })
                    .catch(error => {
                        console.error(`Error updating ${collectionName} messages:`, error);
                    });
            }
        }
        
        // Expose functions to profile page
        window.updateChatMessagesUsername = updateChatMessagesUsername;
        window.updateFirestoreMessagesUsername = updateFirestoreMessagesUsername;

        // Profanity filter - list of bad words (case-insensitive)
        const badWords = [
            'damn', 'hell', 'crap', 'stupid', 'idiot', 'dumb', 'shut up', 'shutup',
            'hate', 'kill', 'die', 'moron', 'loser', 'ugly', 'fat',
            // Profanity
            'fuck', 'fucking', 'fucked', 'fucker', 'fuckers',
            'shit', 'shitting', 'shitted',
            'ass', 'asses', 'asshole', 'assholes',
            'bitch', 'bitches', 'bitching',
            'bastard', 'bastards',
            'piss', 'pissing', 'pissed',
            'damn', 'damned', 'damnit', 'dammit',
            'crap', 'crappy',
            'dick', 'dicks',
            'cock', 'cocks',
            'pussy', 'pussies',
            'whore', 'whores',
            'slut', 'sluts',
            'nigger', 'niggers', 'nigga', 'niggas',
            'retard', 'retarded', 'retards',
            'gay', 'fag', 'fags', 'faggot', 'faggots',
            'cunt', 'cunts',
            'douche', 'douchebag', 'douchebags',
            'screw', 'screwed', 'screwing',
            'suck', 'sucks', 'sucking', 'sucked',
            'bullshit', 'bullshitting',
            'motherfucker', 'motherfuckers',
            'son of a bitch', 'sonofabitch',
            // Add more words as needed
        ];

        // Function to censor bad words in a message
        function censorMessage(message) {
            if (!message || typeof message !== 'string') return message;
            
            let censoredMessage = message;
            const replacement = 'kind word';
            
            // Create regex patterns for each bad word (case-insensitive, word boundaries)
            badWords.forEach(badWord => {
                // Escape special regex characters
                const escapedWord = badWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Match whole words only (case-insensitive)
                const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
                censoredMessage = censoredMessage.replace(regex, replacement);
            });
            
            return censoredMessage;
        }

        // Send message
        function sendMessage() {
            // IMMEDIATE BAN CHECK - DO THIS FIRST BEFORE ANYTHING ELSE
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (profileData) {
                    const profile = JSON.parse(profileData);
                    const checkUserId = profile.userId || null;
                    const checkUsername = profile.username || profile.displayName || currentUserName || '';
                    const allBans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                    const now = Date.now();
                    
                    // Check every ban
                    for (const banKey in allBans) {
                        const ban = allBans[banKey];
                        if (ban.bannedUntil <= now) continue;
                        
                        // Check userId match
                        if (checkUserId && (banKey === checkUserId || ban.bannedUserId === checkUserId)) {
                            console.log('üö´ IMMEDIATE BLOCK: User banned by userId');
                            disableChatBanned();
                            messageInput.value = '';
                            alert('You are banned and cannot send messages.');
                            return;
                        }
                        
                        // Check username match
                        const bannedUsername = ban.bannedUsername || banKey;
                        if (checkUsername && checkUsername.trim().toLowerCase() === bannedUsername.trim().toLowerCase()) {
                            console.log('üö´ IMMEDIATE BLOCK: User banned by username');
                            disableChatBanned();
                            messageInput.value = '';
                            alert('You are banned and cannot send messages.');
                            return;
                        }
                        
                        // Check banKey match
                        if (checkUsername && banKey.trim().toLowerCase() === checkUsername.trim().toLowerCase()) {
                            console.log('üö´ IMMEDIATE BLOCK: User banned by banKey');
                            disableChatBanned();
                            messageInput.value = '';
                            alert('You are banned and cannot send messages.');
                            return;
                        }
                    }
                }
            } catch (e) {
                console.error('Error in immediate ban check:', e);
            }
            
            let message = messageInput.value.trim();
            if ((message === '' && !selectedImage && !selectedGif) || !currentUserName) return;

            // Check for chat code secret: "JNJ2025"
            if (message.toLowerCase() === 'jnj2025' && window.secretPages) {
                if (window.secretPages.unlock('chatcode')) {
                    // Redirect is handled in unlockSecret
                } else if (window.secretPages.isUnlocked('chatcode')) {
                    window.location.href = 'secrets.html';
                }
                messageInput.value = '';
                return;
            }

            // Always get the latest username, userId, and avatar from profile FIRST
            let messageUsername = currentUserName;
            let messageUserId = null;
            let messageAvatar = 'üë§';
            let messageAvatarImage = null;
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (profileData) {
                    const profile = JSON.parse(profileData);
                    
                    // Generate userId for old profiles that don't have one
                    if (!profile.userId) {
                        // Generate a unique user ID
                        function generateUserId() {
                            return 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15);
                        }
                        profile.userId = generateUserId();
                        localStorage.setItem('jnjUserProfile', JSON.stringify(profile));
                        console.log('Generated userId for old profile when sending message:', profile.userId);
                    }
                    
                    // Get userId (required for banning)
                    messageUserId = profile.userId || null;
                    // Use username if available, otherwise use displayName
                    if (profile.username && profile.username.trim() !== '') {
                        messageUsername = profile.username.trim();
                        // Update currentUserName to keep it in sync
                        currentUserName = messageUsername;
                    } else if (profile.displayName && profile.displayName.trim() !== '') {
                        messageUsername = profile.displayName.trim();
                        currentUserName = messageUsername;
                    }
                    // Get avatar
                    if (profile.avatarImage) {
                        messageAvatarImage = profile.avatarImage;
                    } else if (profile.avatar) {
                        messageAvatar = profile.avatar;
                    }
                }
            } catch (e) {
                // Ignore errors, use currentUserName
            }
            
            // Check if user is banned - CHECK EVERYTHING POSSIBLE
            let isBanned = false;
            let banReason = '';
            
            // Get all bans from localStorage
            const allBans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
            console.log('=== BAN CHECK DEBUG ===');
            console.log('Checking ban for user:', messageUsername, 'userId:', messageUserId);
            console.log('All bans in localStorage:', allBans);
            
            // Check EVERY ban entry to see if it matches this user
            for (const banKey in allBans) {
                const ban = allBans[banKey];
                const now = Date.now();
                
                // Skip expired bans
                if (ban.bannedUntil <= now) {
                    continue;
                }
                
                // Check if this ban matches by userId
                if (messageUserId) {
                    if (banKey === messageUserId || ban.bannedUserId === messageUserId) {
                        console.log('MATCH FOUND: Ban by userId!', banKey, ban);
                        isBanned = true;
                        banReason = 'userId match';
                        break;
                    }
                }
                
                // Check if this ban matches by username
                const bannedUsername = ban.bannedUsername || banKey;
                if (messageUsername && messageUsername.trim().toLowerCase() === bannedUsername.trim().toLowerCase()) {
                    console.log('MATCH FOUND: Ban by username!', banKey, ban);
                    isBanned = true;
                    banReason = 'username match';
                    break;
                }
                
                // Also check if banKey itself matches username (for old bans)
                if (messageUsername && banKey.trim().toLowerCase() === messageUsername.trim().toLowerCase()) {
                    console.log('MATCH FOUND: Ban key matches username!', banKey, ban);
                    isBanned = true;
                    banReason = 'banKey match';
                    break;
                }
            }
            
            console.log('Ban check result:', isBanned, banReason);
            console.log('=== END BAN CHECK ===');
            
            if (isBanned) {
                console.log('üö´ BLOCKING MESSAGE - User is banned!');
                // Disable chat and show ban message
                disableChatBanned();
                // Clear the input
                messageInput.value = '';
                // Show alert to user
                alert('You are banned and cannot send messages.');
                return;
            }
            
            // Censor the message before sending
            message = censorMessage(message);

            const timestamp = Date.now();
            const imageData = selectedImage;
            const gifData = selectedGif;
            
            // Clear image preview
            if (selectedImage) {
                selectedImage = null;
                document.getElementById('imagePreview').style.display = 'none';
                document.getElementById('previewImage').src = '';
                document.getElementById('imageInput').value = '';
            }
            
            // Clear GIF preview
            if (selectedGif) {
                selectedGif = null;
                document.getElementById('gifPreview').style.display = 'none';
                document.getElementById('previewGif').src = '';
            }
            
            console.log('Sending message:', { user: messageUsername, message: message, hasImage: !!imageData, hasGif: !!gifData, gifUrl: gifData, avatar: messageAvatar, avatarImage: !!messageAvatarImage });
            
            if (db) {
                // Save to Firestore first
                saveMessage(messageUsername, message || '', timestamp, imageData, gifData, messageAvatar, messageAvatarImage, messageUserId);
                
                // Add to display immediately for better UX
                addMessageToChat(messageUsername, message || '', timestamp, false, imageData, gifData, messageAvatar, messageAvatarImage, null, messageUserId);
            } else {
                addMessageToChat(messageUsername, message || '', timestamp, true, imageData, gifData, messageAvatar, messageAvatarImage, null, messageUserId);
            }
            messageInput.value = '';
            messageInput.focus();
        }
        
        let selectedGif = null; // Store selected GIF URL
        
        // Handle image selection
        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Check file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                alert('Image is too large! Maximum size is 5MB.');
                event.target.value = '';
                return;
            }
            
            // Check if it's an image
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file.');
                event.target.value = '';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                selectedImage = e.target.result; // Store as base64
                document.getElementById('previewImage').src = selectedImage;
                document.getElementById('imagePreview').style.display = 'flex';
            };
            reader.readAsDataURL(file);
        }
        
        // Remove selected image
        function removeImage() {
            selectedImage = null;
            document.getElementById('imagePreview').style.display = 'none';
            document.getElementById('previewImage').src = '';
            document.getElementById('imageInput').value = '';
        }
        
        // Expand image on click
        function expandImage(imgElement) {
            // Remove any existing expanded image
            const existingExpanded = document.querySelector('.expanded-image-overlay');
            if (existingExpanded) {
                existingExpanded.remove();
            }
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'expanded-image-overlay';
            overlay.innerHTML = `
                <div class="expanded-image-container">
                    <button class="close-expanded-image">‚úï</button>
                    <img src="${imgElement.src}" alt="Expanded image" class="expanded-image">
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay || e.target.classList.contains('close-expanded-image')) {
                    overlay.remove();
                }
            });
            
            // Close on Escape key
            const closeHandler = (e) => {
                if (e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', closeHandler);
                }
            };
            document.addEventListener('keydown', closeHandler);
        }

        // Save name handler

        // Generate a 6-digit room code
        function generateRoomCode() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }
        
        // Create a private room
        function createRoom() {
            if (!currentUserName) {
                alert('Please enter your name first.');
                return;
            }
            
            const roomCode = generateRoomCode();
            const roomCreationTime = Date.now();
            currentRoomCode = roomCode;
            localStorage.setItem('jjnChatRoomCode', roomCode);
            
            // Save room metadata to Firestore
            if (db) {
                db.collection('rooms').doc(roomCode).set({
                    code: roomCode,
                    createdAt: roomCreationTime,
                    createdBy: currentUserName
                }, { merge: false })
                .then(() => {
                    console.log('Room created successfully:', roomCode, 'at', new Date(roomCreationTime));
                })
                .catch((error) => {
                    console.error('Error creating room:', error);
                });
            } else {
                // Fallback: save to localStorage
                const rooms = JSON.parse(localStorage.getItem('jjnChatRooms') || '{}');
                rooms[roomCode] = {
                    code: roomCode,
                    createdAt: roomCreationTime,
                    createdBy: currentUserName
                };
                localStorage.setItem('jjnChatRooms', JSON.stringify(rooms));
                console.log('Room saved to localStorage:', roomCode, 'at', new Date(roomCreationTime));
            }
            
            // Update UI
            updateRoomUI();
            
            // Show modal with code to copy
            roomCodeDisplayText.textContent = roomCode;
            roomCodeModal.style.display = 'flex';
            
            // Clear chat and show welcome message for private room
            chatMessages.innerHTML = '<div class="message welcome-message"><div class="message-content"><p>Welcome to Private Room ' + roomCode + '!</p></div></div>';
            loadedMessageIds.clear();
            isInitialLoad = true;
            
            // Load messages for this room (will be empty initially)
            if (db) {
                loadMessagesFromFirestore(roomCode);
            } else {
                // Fallback: reload from localStorage with room filter
                loadMessages();
            }
        }
        
        // Join a private room
        function joinRoom() {
            if (!currentUserName) {
                alert('Please enter your name first.');
                return;
            }
            
            joinRoomModal.style.display = 'flex';
            roomCodeInput.focus();
        }
        
        // Confirm join room
        function confirmJoin() {
            const code = roomCodeInput.value.trim().toLowerCase();
            
            // Special dev code: 000001 redirects to dev secrets page
            if (code === '000001') {
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
                window.location.href = 'dev-secrets.html';
                return;
            }
            
            // Special dev chat room code: "bzn mt" or "bznmt"
            if (code === 'bzn mt' || code === 'bznmt') {
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
                
                // Join the dev chat room
                currentRoomCode = 'devchat';
                localStorage.setItem('jjnChatRoomCode', 'devchat');
                
                // Apply dev chat styling
                document.body.classList.add('dev-chat-active');
                const chatContainer = document.getElementById('chatContainer');
                const chatHeader = document.getElementById('chatHeader');
                const chatTitle = document.getElementById('chatTitle');
                if (chatContainer) chatContainer.classList.add('dev-chat');
                if (chatHeader) chatHeader.classList.add('dev-chat-header');
                if (chatTitle) chatTitle.textContent = 'üîß Dev Chat';
                
                // Update UI
                updateRoomUI();
                
                // Show dev star button
                showDevStarIfNeeded();
                
                // Clear chat and show welcome message for dev room
                chatMessages.innerHTML = '<div class="message welcome-message dev-welcome"><div class="message-content"><p>üîß Welcome to Dev Chat Room!</p><p style="margin-top: 10px; font-size: 14px; opacity: 0.8;">This is a secret developer chat room.</p></div></div>';
                loadedMessageIds.clear();
                isInitialLoad = true;
                
                // Load messages for dev room
                if (db) {
                    loadMessagesFromFirestore('devchat');
                } else {
                    // Fallback: reload from localStorage with room filter
                    loadMessages();
                }
                return;
            }
            
            // Regular room code validation (6 digits)
            if (code.length !== 6 || !/^\d+$/.test(code)) {
                alert('Please enter a valid 6-digit room code.');
                return;
            }
            
            // Show loading state
            const originalButtonText = confirmJoinButton.textContent;
            confirmJoinButton.textContent = 'Checking...';
            confirmJoinButton.disabled = true;
            
            // Check if room exists and is valid (created within past week)
            checkRoomValidity(code).then((isValid) => {
                confirmJoinButton.textContent = originalButtonText;
                confirmJoinButton.disabled = false;
                
                if (!isValid) {
                    alert('Room code not found or expired. Rooms expire after 7 days.');
                    roomCodeInput.value = '';
                    return;
                }
                
                // Room is valid, join it
                currentRoomCode = code;
                localStorage.setItem('jjnChatRoomCode', code);
                
                // Update UI
                updateRoomUI();
                
                // Close modal
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
                
                // Clear chat and show welcome message for private room
                chatMessages.innerHTML = '<div class="message welcome-message"><div class="message-content"><p>Welcome to Private Room ' + code + '!</p></div></div>';
                loadedMessageIds.clear();
                isInitialLoad = true;
                
                // Load messages for this room
                if (db) {
                    loadMessagesFromFirestore(code);
                } else {
                    // Fallback: reload from localStorage with room filter
                    loadMessages();
                }
            }).catch((error) => {
                console.error('Error checking room validity:', error);
                confirmJoinButton.textContent = originalButtonText;
                confirmJoinButton.disabled = false;
                alert('Error checking room code. Please try again.');
            });
        }
        
        // Check if a room code is valid (exists and was created within past week)
        function checkRoomValidity(roomCode, retryCount = 0) {
            const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000); // 7 days in milliseconds
            const maxRetries = 3;
            const retryDelay = 500; // 500ms delay between retries
            
            if (db) {
                // Check Firestore
                return db.collection('rooms').doc(roomCode).get()
                    .then((doc) => {
                        if (!doc.exists) {
                            // If room doesn't exist and we haven't retried, wait and try again
                            // This handles the case where room was just created but not yet saved
                            if (retryCount < maxRetries) {
                                console.log(`Room not found, retrying... (${retryCount + 1}/${maxRetries})`);
                                return new Promise((resolve) => {
                                    setTimeout(() => {
                                        checkRoomValidity(roomCode, retryCount + 1).then(resolve);
                                    }, retryDelay);
                                });
                            }
                            console.log('Room does not exist:', roomCode);
                            return false;
                        }
                        
                        const roomData = doc.data();
                        const createdAt = roomData.createdAt || 0;
                        
                        console.log('Room check:', {
                            code: roomCode,
                            createdAt: createdAt,
                            createdAtDate: new Date(createdAt),
                            oneWeekAgo: oneWeekAgo,
                            oneWeekAgoDate: new Date(oneWeekAgo),
                            isValid: createdAt >= oneWeekAgo,
                            timeDiff: Date.now() - createdAt,
                            timeDiffDays: (Date.now() - createdAt) / (24 * 60 * 60 * 1000)
                        });
                        
                        if (createdAt === 0) {
                            console.log('Room has no creation timestamp:', roomCode);
                            return false;
                        }
                        
                        if (createdAt < oneWeekAgo) {
                            console.log('Room expired:', roomCode, 'Created:', new Date(createdAt), 'Now:', new Date());
                            // Optionally delete expired room
                            db.collection('rooms').doc(roomCode).delete().catch(err => console.error('Error deleting expired room:', err));
                            return false;
                        }
                        
                        console.log('Room is valid:', roomCode, 'Created:', new Date(createdAt));
                        return true;
                    })
                    .catch((error) => {
                        console.error('Error checking room in Firestore:', error);
                        // Retry on error if we haven't exceeded max retries
                        if (retryCount < maxRetries) {
                            console.log(`Error checking room, retrying... (${retryCount + 1}/${maxRetries})`);
                            return new Promise((resolve) => {
                                setTimeout(() => {
                                    checkRoomValidity(roomCode, retryCount + 1).then(resolve);
                                }, retryDelay);
                            });
                        }
                        return false;
                    });
            } else {
                // Fallback: check localStorage
                return new Promise((resolve) => {
                    const rooms = JSON.parse(localStorage.getItem('jjnChatRooms') || '{}');
                    const room = rooms[roomCode];
                    
                    if (!room) {
                        console.log('Room does not exist in localStorage:', roomCode);
                        resolve(false);
                        return;
                    }
                    
                    const createdAt = room.createdAt || 0;
                    if (createdAt === 0) {
                        console.log('Room has no creation timestamp in localStorage:', roomCode);
                        resolve(false);
                        return;
                    }
                    
                    if (createdAt < oneWeekAgo) {
                        console.log('Room expired in localStorage:', roomCode);
                        // Remove expired room
                        delete rooms[roomCode];
                        localStorage.setItem('jjnChatRooms', JSON.stringify(rooms));
                        resolve(false);
                        return;
                    }
                    
                    console.log('Room is valid in localStorage:', roomCode);
                    resolve(true);
                });
            }
        }
        
        // Check if user is a dev
        function isDev() {
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (profileData) {
                    const profile = JSON.parse(profileData);
                    return profile.isDev === true;
                }
            } catch (e) {
                console.error('Error checking dev status:', e);
            }
            return false;
        }

        // Check if dev chat is active on page load
        function checkDevChatOnLoad() {
            if (currentRoomCode === 'devchat') {
                document.body.classList.add('dev-chat-active');
                const chatContainer = document.getElementById('chatContainer');
                const chatHeader = document.getElementById('chatHeader');
                const chatTitle = document.getElementById('chatTitle');
                if (chatContainer) chatContainer.classList.add('dev-chat');
                if (chatHeader) chatHeader.classList.add('dev-chat-header');
                if (chatTitle) chatTitle.textContent = 'üîß Dev Chat';
                
                // Show dev star button if user is not already a dev
                if (devStarButton) {
                    if (!isDev()) {
                        devStarButton.style.display = 'block';
                        console.log('Showing dev star button - user is not a dev');
                    } else {
                        devStarButton.style.display = 'none';
                        console.log('Hiding dev star button - user is already a dev');
                    }
                } else {
                    console.error('devStarButton element not found!');
                }
            } else {
                if (devStarButton) {
                    devStarButton.style.display = 'none';
                }
            }
        }
        
        // Also check when joining dev chat
        function showDevStarIfNeeded() {
            console.log('showDevStarIfNeeded called', { currentRoomCode, isDev: isDev(), devStarButton: !!devStarButton });
            if (currentRoomCode === 'devchat' && devStarButton) {
                if (!isDev()) {
                    devStarButton.style.display = 'block';
                    devStarButton.style.visibility = 'visible';
                    console.log('Showing dev star button - user is not a dev');
                } else {
                    devStarButton.style.display = 'none';
                    console.log('Hiding dev star button - user is already a dev');
                }
            }
        }
        
        // Handle dev star button click
        if (devStarButton) {
            devStarButton.addEventListener('click', () => {
                if (isDev()) {
                    alert('You are already a dev!');
                    return;
                }
                devPasswordModal.style.display = 'flex';
                devPasswordInput.focus();
            });
        }
        
        // Handle dev password submission
        function submitDevPasswordHandler() {
            const password = devPasswordInput.value.trim();
            if (password === DEV_PASSWORD) {
                // Save dev status to profile
                try {
                    const profileData = localStorage.getItem('jnjUserProfile');
                    let profile = {};
                    if (profileData) {
                        profile = JSON.parse(profileData);
                    }
                    profile.isDev = true;
                    localStorage.setItem('jnjUserProfile', JSON.stringify(profile));
                    
                    // Hide star button and close modal
                    devStarButton.style.display = 'none';
                    devPasswordModal.style.display = 'none';
                    devPasswordInput.value = '';
                    alert('‚≠ê Dev access granted! You now have moderation tools.');
                    
                    // Setup message handlers for newly granted dev
                    setupMessageClickHandlers();
                } catch (e) {
                    console.error('Error saving dev status:', e);
                    alert('Error saving dev status. Please try again.');
                }
            } else {
                alert('Incorrect password!');
                devPasswordInput.value = '';
                devPasswordInput.focus();
            }
        }
        
        if (submitDevPassword) {
            submitDevPassword.addEventListener('click', submitDevPasswordHandler);
        }
        
        if (devPasswordInput) {
            devPasswordInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitDevPasswordHandler();
                }
            });
        }
        
        // Cancel dev password modal
        if (cancelDevPassword) {
            cancelDevPassword.addEventListener('click', () => {
                devPasswordModal.style.display = 'none';
                devPasswordInput.value = '';
            });
        }
        
        // Handle message click for dev users
        function setupMessageClickHandlers() {
            if (!isDev()) return;
            
            const messages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            messages.forEach(msg => {
                // Remove existing handler to avoid duplicates
                msg.removeEventListener('click', handleMessageClick);
                msg.addEventListener('click', handleMessageClick);
                msg.style.cursor = 'pointer';
                msg.title = 'Click to moderate (Dev only)';
            });
        }
        
        function handleMessageClick(e) {
            if (!isDev()) return;
            
            const messageDiv = e.currentTarget;
            const messageId = messageDiv.getAttribute('data-message-id');
            const userSpan = messageDiv.querySelector('.message-user');
            const username = userSpan ? userSpan.textContent.trim() : 'Unknown';
            // Get userId from message element (preferred)
            let userId = messageDiv.getAttribute('data-user-id');
            
            // If userId not in DOM, try to get it from Firestore
            if (!userId && messageId && db && !messageId.startsWith('temp-')) {
                const roomCode = currentRoomCode || null;
                const collection = roomCode ? 'roomMessages' : 'messages';
                db.collection(collection).doc(messageId).get().then(doc => {
                    if (doc.exists()) {
                        const data = doc.data();
                        if (data.userId) {
                            selectedUserIdForBan = data.userId;
                            // Also update the DOM element for future reference
                            messageDiv.setAttribute('data-user-id', data.userId);
                        }
                    }
                }).catch(err => {
                    console.error('Error fetching userId from Firestore:', err);
                });
            }
            
            selectedMessageForAction = messageDiv;
            selectedUserForBan = username;
            selectedUserIdForBan = userId; // Store userId for banning
            
            messageActionsUser.textContent = `User: ${username}`;
            messageActionsModal.style.display = 'flex';
        }
        
        // Delete message
        if (deleteMessageBtn) {
            deleteMessageBtn.addEventListener('click', () => {
                if (!selectedMessageForAction || !isDev()) return;
                
                const messageId = selectedMessageForAction.getAttribute('data-message-id');
                const roomCode = currentRoomCode || null;
                const collection = roomCode ? 'roomMessages' : 'messages';
                
                console.log('Deleting message:', { messageId, roomCode, collection, hasDb: !!db });
                
                if (db && messageId && !messageId.startsWith('temp-')) {
                    // Delete from Firestore
                    const docRef = db.collection(collection).doc(messageId);
                    docRef.delete()
                        .then(() => {
                            console.log('Message deleted from Firestore successfully:', messageId);
                            selectedMessageForAction.remove();
                            messageActionsModal.style.display = 'none';
                        })
                        .catch(error => {
                            console.error('Error deleting message from Firestore:', error);
                            console.error('Error details:', error.code, error.message);
                            // Still remove from DOM even if Firestore delete fails
                            selectedMessageForAction.remove();
                            messageActionsModal.style.display = 'none';
                            alert('Message removed from view, but there was an error deleting from database. Error: ' + error.message);
                        });
                } else if (db && messageId && messageId.startsWith('temp-')) {
                    // Temp message - just remove from DOM
                    console.log('Removing temp message from DOM');
                    selectedMessageForAction.remove();
                    messageActionsModal.style.display = 'none';
                } else if (!db) {
                    // No Firestore - delete from localStorage
                    console.log('Deleting from localStorage (no Firestore)');
                    const timestamp = selectedMessageForAction.getAttribute('data-timestamp');
                    const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                    const filteredMessages = messages.filter(msg => {
                        if (roomCode) {
                            return !(msg.timestamp == timestamp && msg.roomCode === roomCode);
                        } else {
                            return !(msg.timestamp == timestamp && !msg.roomCode);
                        }
                    });
                    localStorage.setItem('jjnChatMessages', JSON.stringify(filteredMessages));
                    selectedMessageForAction.remove();
                    messageActionsModal.style.display = 'none';
                } else {
                    // No message ID - just remove from DOM
                    console.log('No message ID, removing from DOM only');
                    selectedMessageForAction.remove();
                    messageActionsModal.style.display = 'none';
                }
            });
        }
        
        // Ban user
        if (banUserBtn) {
            banUserBtn.addEventListener('click', () => {
                if (!selectedUserForBan || !isDev()) return;
                
                banUserInfo.textContent = `Ban user: ${selectedUserForBan}`;
                messageActionsModal.style.display = 'none';
                banDurationModal.style.display = 'flex';
            });
        }
        
        // Confirm ban
        if (confirmBanBtn) {
            confirmBanBtn.addEventListener('click', () => {
                if (!selectedUserForBan || !isDev()) return;
                
                // Try to get userId from the message element if we don't have it yet
                let userIdToBan = selectedUserIdForBan;
                if (!userIdToBan && selectedMessageForAction) {
                    userIdToBan = selectedMessageForAction.getAttribute('data-user-id');
                }
                
                // If still no userId, try to get it from Firestore message document
                if (!userIdToBan && selectedMessageForAction && db) {
                    const messageId = selectedMessageForAction.getAttribute('data-message-id');
                    if (messageId && !messageId.startsWith('temp-')) {
                        const roomCode = currentRoomCode || null;
                        const collection = roomCode ? 'roomMessages' : 'messages';
                        // Try to get userId synchronously by checking if we can find it in recent messages
                        // For now, we'll proceed with username-based ban if userId not available
                        console.warn('No userId found for user:', selectedUserForBan, '- using username-based ban (less secure)');
                    }
                }
                
                const durationMinutes = parseInt(banDurationSelect.value);
                const banUntil = Date.now() + (durationMinutes * 60 * 1000);
                
                // Use userId as the ban key (preferred), or username as fallback
                const banKey = userIdToBan || selectedUserForBan.trim();
                // Update selectedUserIdForBan for use in message removal
                selectedUserIdForBan = userIdToBan;
                
                // Save ban to localStorage and Firestore
                const bans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                bans[banKey] = {
                    bannedUntil: banUntil,
                    bannedBy: currentUserName,
                    bannedAt: Date.now(),
                    bannedUsername: selectedUserForBan.trim(), // Store username for display purposes
                    bannedUserId: userIdToBan // Store userId if available
                };
                localStorage.setItem('jnjChatBans', JSON.stringify(bans));
                
                console.log('üî® BAN SAVED:', {
                    user: selectedUserForBan,
                    userId: userIdToBan || 'none',
                    banKey: banKey,
                    until: new Date(banUntil),
                    allBans: bans
                });
                
                // Immediately check if the banned user is the current user and disable their chat
                try {
                    const profileData = localStorage.getItem('jnjUserProfile');
                    if (profileData) {
                        const profile = JSON.parse(profileData);
                        const currentUserId = profile.userId || null;
                        const currentUsername = profile.username || profile.displayName || currentUserName || '';
                        
                        // Check multiple ways to see if current user was banned
                        let currentUserBanned = false;
                        
                        // Check by userId
                        if (currentUserId && userIdToBan && currentUserId === userIdToBan) {
                            console.log('Current user was banned by userId - disabling chat immediately');
                            currentUserBanned = true;
                        }
                        
                        // Check by username (case-insensitive)
                        if (!currentUserBanned && currentUsername && currentUsername.trim().toLowerCase() === selectedUserForBan.trim().toLowerCase()) {
                            console.log('Current user was banned by username - disabling chat immediately');
                            currentUserBanned = true;
                        }
                        
                        // Also check if ban key matches current username (for username-based bans)
                        if (!currentUserBanned && !userIdToBan && currentUsername && banKey === currentUsername.trim()) {
                            console.log('Current user was banned (ban key matches username) - disabling chat immediately');
                            currentUserBanned = true;
                        }
                        
                        if (currentUserBanned) {
                            disableChatBanned();
                            // Force immediate ban check
                            checkBanStatusPeriodically();
                        }
                    }
                } catch (e) {
                    console.error('Error checking if current user was banned:', e);
                }
                
                // Also save to Firestore if available
                if (db) {
                    db.collection('bans').doc(banKey).set({
                        bannedUntil: banUntil,
                        bannedBy: currentUserName,
                        bannedAt: Date.now(),
                        bannedUsername: selectedUserForBan.trim(),
                        bannedUserId: userIdToBan
                    }).then(() => {
                        console.log('Ban saved to Firestore for:', banKey);
                    }).catch(error => {
                        console.error('Error saving ban to Firestore:', error);
                    });
                    
                    // Delete all messages from banned user from Firestore
                    const roomCode = currentRoomCode || null;
                    const collection = roomCode ? 'roomMessages' : 'messages';
                    
                    // Delete messages by userId if available, otherwise by username
                    let query;
                    if (userIdToBan) {
                        query = db.collection(collection).where('userId', '==', userIdToBan);
                    } else {
                        // Fallback to username-based deletion
                        query = db.collection(collection).where('user', '==', selectedUserForBan.trim());
                    }
                    
                    query.get()
                        .then(querySnapshot => {
                            const batch = db.batch();
                            let deleteCount = 0;
                            querySnapshot.forEach(doc => {
                                // Also check room code if in a room
                                if (roomCode) {
                                    const data = doc.data();
                                    if (data.roomCode === roomCode) {
                                        batch.delete(doc.ref);
                                        deleteCount++;
                                    }
                                } else {
                                    // Public chat - only delete if no room code
                                    const data = doc.data();
                                    if (!data.roomCode) {
                                        batch.delete(doc.ref);
                                        deleteCount++;
                                    }
                                }
                            });
                            if (deleteCount > 0) {
                                return batch.commit().then(() => {
                                    console.log(`Deleted ${deleteCount} messages from banned user ${selectedUserForBan} (ID: ${userIdToBan || 'none'})`);
                                });
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting banned user messages from Firestore:', error);
                        });
                }
                
                banDurationModal.style.display = 'none';
                
                // Remove all messages from banned user from DOM immediately
                const userMessages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
                let removedCount = 0;
                userMessages.forEach(msg => {
                    let shouldRemove = false;
                    
                    // Check by userId first (preferred)
                    if (userIdToBan) {
                        const msgUserId = msg.getAttribute('data-user-id');
                        if (msgUserId === userIdToBan) {
                            shouldRemove = true;
                        }
                    }
                    
                    // Also check by username (for messages without userId or as fallback)
                    if (!shouldRemove) {
                        const userSpan = msg.querySelector('.message-user');
                        if (userSpan) {
                            const msgUsername = userSpan.textContent.trim();
                            // Case-insensitive comparison
                            if (msgUsername.toLowerCase() === selectedUserForBan.trim().toLowerCase()) {
                                shouldRemove = true;
                            }
                        }
                    }
                    
                    if (shouldRemove) {
                        msg.remove();
                        removedCount++;
                    }
                });
                
                console.log(`Removed ${removedCount} messages from DOM for banned user ${selectedUserForBan}`);
                
                // Clear selection
                selectedUserForBan = null;
                selectedUserIdForBan = null;
                selectedMessageForAction = null;
            });
        }
        
            // Cancel message actions
        if (cancelMessageActions) {
            cancelMessageActions.addEventListener('click', () => {
                messageActionsModal.style.display = 'none';
                selectedMessageForAction = null;
                selectedUserForBan = null;
                selectedUserIdForBan = null;
            });
        }
        
        // Cancel ban
        if (cancelBanBtn) {
            cancelBanBtn.addEventListener('click', () => {
                banDurationModal.style.display = 'none';
            });
        }
        
        // Load bans from Firestore and sync with localStorage
        function loadBansFromFirestore() {
            if (!db) {
                console.log('Firestore not available, using localStorage bans only');
                return Promise.resolve();
            }
            
            return db.collection('bans').get()
                .then(querySnapshot => {
                    const bans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                    const now = Date.now();
                    
                    querySnapshot.forEach(doc => {
                        const banData = doc.data();
                        const username = doc.id.trim(); // Normalize
                        
                        // Only keep active bans
                        if (banData.bannedUntil > now) {
                            bans[username] = banData;
                            console.log('Loaded active ban for:', username, 'until', new Date(banData.bannedUntil));
                        } else {
                            // Remove expired bans
                            delete bans[username];
                            console.log('Removed expired ban for:', username);
                        }
                    });
                    
                    // Also clean up expired bans from localStorage
                    Object.keys(bans).forEach(username => {
                        if (bans[username].bannedUntil <= now) {
                            delete bans[username];
                            console.log('Removed expired ban from localStorage:', username);
                        }
                    });
                    
                    localStorage.setItem('jnjChatBans', JSON.stringify(bans));
                    console.log('Bans synced from Firestore. Total active bans:', Object.keys(bans).length);
                    console.log('Active bans:', Object.keys(bans));
                    
                    // Update UI if current user is banned
                    if (currentUserName) {
                        checkBanStatusPeriodically();
                    }
                })
                .catch(error => {
                    console.error('Error loading bans from Firestore:', error);
                });
        }
        
        // Check if user is banned by userId (preferred method)
        function isUserBannedById(userId) {
            if (!userId) return false;
            
            try {
                // Check localStorage (fast, synchronous)
                const bans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                
                // Check all bans by userId
                for (const banKey in bans) {
                    const ban = bans[banKey];
                    // Check if this ban is for the userId (either the key is the userId, or ban.bannedUserId matches)
                    if (banKey === userId || ban.bannedUserId === userId) {
                        // Check if ban is still active
                        if (ban.bannedUntil > Date.now()) {
                            console.log('User is banned by ID:', userId, 'until', new Date(ban.bannedUntil));
                            return true;
                        } else {
                            // Ban expired, remove it
                            delete bans[banKey];
                            localStorage.setItem('jnjChatBans', JSON.stringify(bans));
                            // Also remove from Firestore if available
                            if (db) {
                                db.collection('bans').doc(banKey).delete().catch(err => {
                                    console.error('Error removing expired ban from Firestore:', err);
                                });
                            }
                        }
                    }
                }
            } catch (e) {
                console.error('Error checking ban status by ID:', e);
            }
            return false;
        }
        
        // Check if user is banned before sending message (synchronous check) - username-based (for backwards compatibility)
        function isUserBanned(username) {
            if (!username) return false;
            
            // Normalize username (trim and lowercase for comparison)
            const normalizedUsername = username.trim().toLowerCase();
            
            try {
                // Check localStorage (fast, synchronous)
                const bans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                
                // Check all bans (case-insensitive comparison)
                for (const banKey in bans) {
                    const ban = bans[banKey];
                    // Check if ban is for this username (either key matches username, or bannedUsername matches)
                    const bannedUsername = ban.bannedUsername || banKey;
                    const normalizedBanned = bannedUsername.trim().toLowerCase();
                    if (normalizedBanned === normalizedUsername) {
                        // Check if ban is still active
                        if (ban.bannedUntil > Date.now()) {
                            console.log('User is banned:', username, '(matched:', bannedUsername, ') until', new Date(ban.bannedUntil));
                            return true;
                        } else {
                            // Ban expired, remove it
                            delete bans[banKey];
                            localStorage.setItem('jnjChatBans', JSON.stringify(bans));
                            // Also remove from Firestore if available
                            if (db) {
                                db.collection('bans').doc(banKey).delete().catch(err => {
                                    console.error('Error removing expired ban from Firestore:', err);
                                });
                            }
                        }
                    }
                }
            } catch (e) {
                console.error('Error checking ban status:', e);
            }
            return false;
        }
        
        // Check ban status periodically and update UI
        function checkBanStatusPeriodically() {
            if (currentUserName) {
                try {
                    const profileData = localStorage.getItem('jnjUserProfile');
                    if (profileData) {
                        const profile = JSON.parse(profileData);
                        const userId = profile.userId || null;
                        // Check by userId first (preferred)
                        if (userId && isUserBannedById(userId)) {
                            disableChatBanned();
                            return;
                        }
                    }
                } catch (e) {
                    // Ignore errors
                }
                // Fallback to username check
                if (isUserBanned(currentUserName)) {
                    disableChatBanned();
                } else {
                    // Make sure chat is enabled if not banned
                    if (messageInput.disabled && currentUserName) {
                        enableChat();
                    }
                }
            }
        }
        
        // Check ban status every 30 seconds
        setInterval(checkBanStatusPeriodically, 30000);
        
        // Set up real-time listener for bans
        function setupBanListener() {
            if (!db) return;
            
            // Get userId from profile
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (!profileData) return;
                
                const profile = JSON.parse(profileData);
                const userId = profile.userId || null;
                
                if (!userId) {
                    // Fallback to username-based listener for backwards compatibility
                    if (!currentUserName) return;
                    db.collection('bans').doc(currentUserName.trim()).onSnapshot(setupBanListenerCallback);
                    return;
                }
                
                // Listen for changes to the current user's ban document by userId
                db.collection('bans').doc(userId).onSnapshot(setupBanListenerCallback);
            } catch (e) {
                console.error('Error setting up ban listener:', e);
            }
        }
        
        function setupBanListenerCallback(doc) {
            if (doc.exists()) {
                const banData = doc.data();
                const now = Date.now();
                
                if (banData.bannedUntil > now) {
                    // User was just banned or ban was updated
                    console.log('Real-time ban detected until', new Date(banData.bannedUntil));
                    
                    // Update localStorage using userId as key
                    const bans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                    const banKey = doc.id;
                    bans[banKey] = banData;
                    localStorage.setItem('jnjChatBans', JSON.stringify(bans));
                    
                    // Immediately disable chat
                    disableChatBanned();
                } else {
                    // Ban expired
                    console.log('Ban expired');
                    const bans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                    delete bans[doc.id];
                    localStorage.setItem('jnjChatBans', JSON.stringify(bans));
                    
                    // Re-enable chat if user has a profile
                    enableChat();
                }
            } else {
                // Ban document was deleted (ban lifted)
                console.log('Ban removed');
                const bans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                delete bans[doc.id];
                localStorage.setItem('jnjChatBans', JSON.stringify(bans));
                
                // Re-enable chat if user has a profile
                enableChat();
            }
        }
        
        // Leave private room and return to public chat
        function leaveRoom() {
            if (!confirm('Leave this private room and return to public chat?')) {
                return;
            }
            
            // Remove dev chat styling if active
            document.body.classList.remove('dev-chat-active');
            const chatContainer = document.getElementById('chatContainer');
            const chatHeader = document.getElementById('chatHeader');
            const chatTitle = document.getElementById('chatTitle');
            if (chatContainer) chatContainer.classList.remove('dev-chat');
            if (chatHeader) chatHeader.classList.remove('dev-chat-header');
            if (chatTitle) chatTitle.textContent = 'JNJ Chat';
            
            currentRoomCode = null;
            localStorage.removeItem('jjnChatRoomCode');
            
            // Update UI
            updateRoomUI();
            
            // Clear chat and show welcome message for public chat
            chatMessages.innerHTML = '<div class="message welcome-message"><div class="message-content"><p>Welcome to JNJ Chat! Start a conversation below.</p></div></div>';
            loadedMessageIds.clear();
            isInitialLoad = true;
            
            // Load public messages
            if (db) {
                loadMessagesFromFirestore(null);
            } else {
                // Fallback: reload from localStorage
                loadMessages();
            }
        }
        
        // Copy room code to clipboard
        function copyRoomCode() {
            const code = roomCodeDisplayText.textContent;
            navigator.clipboard.writeText(code).then(() => {
                copyRoomCodeButton.textContent = '‚úì';
                copyRoomCodeButton.style.background = 'rgba(81, 207, 102, 0.3)';
                setTimeout(() => {
                    copyRoomCodeButton.textContent = 'üìã';
                    copyRoomCodeButton.style.background = '';
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = code;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                copyRoomCodeButton.textContent = '‚úì';
                setTimeout(() => {
                    copyRoomCodeButton.textContent = 'üìã';
                }, 2000);
            });
        }
        
        // Event listeners
        sendButton.addEventListener('click', () => {
            // Double-check ban before allowing send
            if (messageInput.disabled) {
                console.log('üö´ Send button clicked but input is disabled - user is banned');
                return;
            }
            sendMessage();
        });
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                // Double-check ban before allowing send
                if (messageInput.disabled) {
                    console.log('üö´ Enter key pressed but input is disabled - user is banned');
                    e.preventDefault();
                    return;
                }
                sendMessage();
            }
        });
        document.getElementById('imageInput').addEventListener('change', handleImageSelect);
        document.getElementById('removeImageButton').addEventListener('click', removeImage);
        document.getElementById('removeGifButton').addEventListener('click', () => {
            selectedGif = null;
            document.getElementById('gifPreview').style.display = 'none';
            document.getElementById('previewGif').src = '';
        });
        
        // Emoji picker
        const commonEmojis = ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú', 'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥', 'üòè', 'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ', '‚òπÔ∏è', 'üò£', 'üòñ', 'üò´', 'üò©', 'ü•∫', 'üò¢', 'üò≠', 'üò§', 'üò†', 'üò°', 'ü§¨', 'ü§Ø', 'üò≥', 'ü•µ', 'ü•∂', 'üò±', 'üò®', 'üò∞', 'üò•', 'üòì', 'ü§ó', 'ü§î', 'ü§≠', 'ü§´', 'ü§•', 'üò∂', 'üòê', 'üòë', 'üò¨', 'üôÑ', 'üòØ', 'üò¶', 'üòß', 'üòÆ', 'üò≤', 'ü•±', 'üò¥', 'ü§§', 'üò™', 'üòµ', 'ü§ê', 'ü•¥', 'ü§¢', 'ü§Æ', 'ü§ß', 'üò∑', 'ü§í', 'ü§ï', 'ü§ë', 'ü§†', 'üòà', 'üëø', 'üëπ', 'üë∫', 'ü§°', 'üí©', 'üëª', 'üíÄ', '‚ò†Ô∏è', 'üëΩ', 'üëæ', 'ü§ñ', 'üéÉ', 'üò∫', 'üò∏', 'üòπ', 'üòª', 'üòº', 'üòΩ', 'üôÄ', 'üòø', 'üòæ'];
        
        function initEmojiPicker() {
            emojiGrid.innerHTML = '';
            commonEmojis.forEach(emoji => {
                const emojiButton = document.createElement('button');
                emojiButton.className = 'emoji-item';
                emojiButton.textContent = emoji;
                emojiButton.title = emoji;
                emojiButton.addEventListener('click', () => {
                    const cursorPos = messageInput.selectionStart;
                    const textBefore = messageInput.value.substring(0, cursorPos);
                    const textAfter = messageInput.value.substring(cursorPos);
                    messageInput.value = textBefore + emoji + textAfter;
                    messageInput.focus();
                    messageInput.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);
                    emojiPickerModal.style.display = 'none';
                });
                emojiGrid.appendChild(emojiButton);
            });
        }
        
        // GIF picker functions
        async function loadGIFs(query = 'trending') {
            gifGrid.innerHTML = '<div class="gif-loading">Loading GIFs...</div>';
            
            // If no API key, use a fallback or show message
            if (GIPHY_API_KEY === 'YOUR_GIPHY_API_KEY') {
                gifGrid.innerHTML = '<div class="gif-error">Please add your Giphy API key in chat.html. Get one free at <a href="https://developers.giphy.com/" target="_blank">developers.giphy.com</a></div>';
                return;
            }
            
            try {
                let url;
                if (query === 'trending' || query === '') {
                    url = `https://api.giphy.com/v1/gifs/trending?api_key=${GIPHY_API_KEY}&limit=24&rating=g`;
                } else {
                    url = `https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=24&rating=g`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                gifGrid.innerHTML = '';
                
                if (data.data && data.data.length > 0) {
                    data.data.forEach(gif => {
                        const gifItem = document.createElement('div');
                        gifItem.className = 'gif-item';
                        const gifImg = document.createElement('img');
                        gifImg.src = gif.images.fixed_height_small.url;
                        gifImg.alt = gif.title || 'GIF';
                        gifImg.loading = 'lazy';
                        gifImg.addEventListener('click', () => {
                            selectedGif = gif.images.original.url;
                            console.log('GIF selected:', selectedGif);
                            document.getElementById('previewGif').src = selectedGif;
                            document.getElementById('gifPreview').style.display = 'flex';
                            gifPickerModal.style.display = 'none';
                            gifSearchInput.value = '';
                        });
                        gifItem.appendChild(gifImg);
                        gifGrid.appendChild(gifItem);
                    });
                } else {
                    gifGrid.innerHTML = '<div class="gif-error">No GIFs found. Try a different search.</div>';
                }
            } catch (error) {
                console.error('Error loading GIFs:', error);
                gifGrid.innerHTML = '<div class="gif-error">Error loading GIFs. Please check your API key.</div>';
            }
        }
        
        // Event listeners for emoji and GIF pickers
        emojiButton.addEventListener('click', () => {
            emojiPickerModal.style.display = 'flex';
            initEmojiPicker();
        });
        
        gifButton.addEventListener('click', () => {
            gifPickerModal.style.display = 'flex';
            loadGIFs('trending');
        });
        
        closeEmojiPicker.addEventListener('click', () => {
            emojiPickerModal.style.display = 'none';
        });
        
        closeGifPicker.addEventListener('click', () => {
            gifPickerModal.style.display = 'none';
            gifSearchInput.value = '';
        });
        
        gifSearchButton.addEventListener('click', () => {
            const query = gifSearchInput.value.trim();
            loadGIFs(query || 'trending');
        });
        
        gifSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const query = gifSearchInput.value.trim();
                loadGIFs(query || 'trending');
            }
        });
        
        emojiPickerModal.addEventListener('click', (e) => {
            if (e.target === emojiPickerModal) {
                emojiPickerModal.style.display = 'none';
            }
        });
        
        gifPickerModal.addEventListener('click', (e) => {
            if (e.target === gifPickerModal) {
                gifPickerModal.style.display = 'none';
                gifSearchInput.value = '';
            }
        });
        
        // Room event listeners
        createRoomButton.addEventListener('click', createRoom);
        joinRoomButton.addEventListener('click', joinRoom);
        leaveRoomButton.addEventListener('click', leaveRoom);
        copyRoomCodeButton.addEventListener('click', copyRoomCode);
        closeRoomCodeModal.addEventListener('click', () => {
            roomCodeModal.style.display = 'none';
        });
        confirmJoinButton.addEventListener('click', confirmJoin);
        cancelJoinButton.addEventListener('click', () => {
            joinRoomModal.style.display = 'none';
            roomCodeInput.value = '';
        });
        roomCodeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                confirmJoin();
            }
        });
        roomCodeModal.addEventListener('click', (e) => {
            if (e.target === roomCodeModal) {
                roomCodeModal.style.display = 'none';
            }
        });
        joinRoomModal.addEventListener('click', (e) => {
            if (e.target === joinRoomModal) {
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
            }
        });

        // Initialize on page load
        loadUserName();
        loadMessages();
        
        // Cursor Trail Effect - Smooth line effect
        const trails = [];
        const maxTrails = 50;
        let lastTime = 0;
        
        function createCursorTrail(x, y, delay = 0) {
            setTimeout(() => {
                const trail = document.createElement('div');
                trail.className = 'cursor-trail';
                trail.style.left = x + 'px';
                trail.style.top = y + 'px';
                trail.style.opacity = '0.6';
                document.body.appendChild(trail);
                
                requestAnimationFrame(() => {
                    trail.style.opacity = '0';
                    trail.style.transform = 'translate(-50%, -50%) scale(0.2)';
                });
                
                setTimeout(() => {
                    if (trail.parentNode) {
                        trail.remove();
                    }
                }, 800);
                
                trails.push(trail);
                if (trails.length > maxTrails) {
                    const oldTrail = trails.shift();
                    if (oldTrail && oldTrail.parentNode) {
                        oldTrail.remove();
                    }
                }
            }, delay);
        }
        
        let lastX = 0;
        let lastY = 0;
        let mouseX = 0;
        let mouseY = 0;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            const now = Date.now();
            const timeSinceLastTrail = now - lastTime;
            
            if (timeSinceLastTrail > 8) {
                const distance = Math.sqrt(
                    Math.pow(mouseX - lastX, 2) + Math.pow(mouseY - lastY, 2)
                );
                
                if (distance > 2) {
                    createCursorTrail(mouseX, mouseY);
                    lastX = mouseX;
                    lastY = mouseY;
                    lastTime = now;
                }
            }
        });
    </script>
</body>
</html>

