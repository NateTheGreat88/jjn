<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - JNJ Website</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="chat.css">
    <link rel="stylesheet" href="animated-background.css">
    <link rel="stylesheet" href="secret-pages.css">
    <script src="page-transitions.js" defer></script>
    <script src="secret-pages.js" defer></script>
    <script src="animated-background.js" defer></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <!-- Firebase Config -->
    <script src="firebase-config.js"></script>
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Back to Home</a>
    
    <div class="chat-container" id="chatContainer">
        <header class="chat-header" id="chatHeader">
            <h1 id="chatTitle">JNJ Chat</h1>
            <p class="chat-subtitle">Junhu Choi ‚Ä¢ Jaxon Croskey ‚Ä¢ Nathan DeLuca</p>
            <button id="devStarButton" class="dev-star-button" style="display: none; position: absolute; top: 10px; right: 10px; background: rgba(255, 215, 0, 0.2); border: 2px solid #ffd700; border-radius: 50%; width: 50px; height: 50px; font-size: 28px; cursor: pointer; z-index: 1000; transition: all 0.2s; color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8); box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);" title="Become a Dev">‚≠ê</button>
            <div class="room-controls">
                <button id="createRoomButton" class="room-button" style="display: none;">Create Private Room</button>
                <button id="joinRoomButton" class="room-button" style="display: none;">Join Room</button>
                <button id="leaveRoomButton" class="room-button room-button-leave" style="display: none;">Leave Room</button>
                <div id="roomCodeDisplay" class="room-code-display" style="display: none;">
                    <span>Room: <strong id="currentRoomCodeDisplay"></strong></span>
                </div>
            </div>
        </header>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message welcome-message">
                <div class="message-content">
                    <p>Welcome to JNJ Chat! Start a conversation below.</p>
                </div>
            </div>
        </div>
        
        <div class="chat-input-container">
            <div class="user-name-container" id="userNameContainer" style="display: none;">
                <div class="current-name-display" id="currentNameDisplay">
                    <span>Chatting as: <strong id="currentNameText"></strong></span>
                    <a href="profile.html" class="change-name-button" style="text-decoration: none;">Edit Profile</a>
                </div>
            </div>
            <div class="input-wrapper">
                <button id="emojiButton" class="emoji-button" title="Add Emoji">üòÄ</button>
                <input 
                    type="text" 
                    id="messageInput" 
                    class="message-input" 
                    placeholder="Type a message..."
                    autocomplete="off"
                    disabled
                >
                <button id="gifButton" class="gif-button" title="Add GIF">GIF</button>
                <label for="imageInput" class="image-upload-button" title="Upload Image">
                    üì∑
                </label>
                <input 
                    type="file" 
                    id="imageInput" 
                    accept="image/*"
                    style="display: none;"
                    disabled
                >
                <button id="sendButton" class="send-button" disabled>Send</button>
            </div>
            <div id="imagePreview" class="image-preview" style="display: none;">
                <img id="previewImage" src="" alt="Preview">
                <button id="removeImageButton" class="remove-image-button">‚úï</button>
            </div>
            <div id="gifPreview" class="gif-preview" style="display: none;">
                <img id="previewGif" src="" alt="GIF Preview">
                <button id="removeGifButton" class="remove-image-button">‚úï</button>
            </div>
        </div>
    </div>

    <!-- Room Code Modal -->
    <div id="roomCodeModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Private Room Created!</h2>
            <p style="color: #b0b0b0; margin-bottom: 20px; text-align: center;">Share this code with your friends:</p>
            <div class="room-code-display-large">
                <span id="roomCodeDisplayText"></span>
                <button id="copyRoomCodeButton" class="copy-button" title="Copy code">üìã</button>
            </div>
            <button id="closeRoomCodeModal" class="modal-button" style="margin-top: 20px;">Close</button>
        </div>
    </div>

    <!-- Join Room Modal -->
    <div id="joinRoomModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Join Private Room</h2>
            <input type="text" id="roomCodeInput" placeholder="Enter room code..." maxlength="10">
            <div class="modal-buttons">
                <button id="confirmJoinButton" class="modal-button">Join</button>
                <button id="cancelJoinButton" class="modal-button modal-button-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Emoji Picker Modal -->
    <div id="emojiPickerModal" class="modal emoji-picker-modal" style="display: none;">
        <div class="modal-content emoji-picker-content">
            <h2>Choose an Emoji</h2>
            <div class="emoji-grid" id="emojiGrid"></div>
            <button id="closeEmojiPicker" class="modal-button" style="margin-top: 15px;">Close</button>
        </div>
    </div>

    <!-- GIF Picker Modal -->
    <div id="gifPickerModal" class="modal gif-picker-modal" style="display: none;">
        <div class="modal-content gif-picker-content">
            <h2>Search GIFs</h2>
            <div class="gif-search-wrapper">
                <input type="text" id="gifSearchInput" class="gif-search-input" placeholder="Search for GIFs...">
                <button id="gifSearchButton" class="gif-search-button">Search</button>
            </div>
            <div class="gif-grid" id="gifGrid">
                <div class="gif-loading">Loading trending GIFs...</div>
            </div>
            <button id="closeGifPicker" class="modal-button" style="margin-top: 15px;">Close</button>
        </div>
    </div>

    <!-- Dev Password Modal -->
    <div id="devPasswordModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <h2>‚≠ê Dev Access</h2>
            <p style="margin-bottom: 20px; opacity: 0.8;">Enter the dev password to unlock moderation tools:</p>
            <input type="password" id="devPasswordInput" class="message-input" placeholder="Enter password..." style="width: 100%; margin-bottom: 15px; padding: 12px;">
            <div style="display: flex; gap: 10px;">
                <button id="submitDevPassword" class="send-button" style="flex: 1;">Submit</button>
                <button id="cancelDevPassword" class="room-button" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Message Actions Modal (for dev users) -->
    <div id="messageActionsModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 400px;">
            <h2>Message Actions</h2>
            <p id="messageActionsUser" style="margin-bottom: 20px; opacity: 0.8;"></p>
            <button id="deleteMessageBtn" class="send-button" style="width: 100%; margin-bottom: 10px; background: #dc2626;">Delete Message</button>
            <button id="banUserBtn" class="send-button" style="width: 100%; margin-bottom: 10px; background: #f59e0b;">Ban User</button>
            <button id="cancelMessageActions" class="room-button" style="width: 100%;">Cancel</button>
        </div>
    </div>

    <!-- Ban Duration Modal -->
    <div id="banDurationModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 400px;">
            <h2>Ban User</h2>
            <p id="banUserInfo" style="margin-bottom: 20px; opacity: 0.8;"></p>
            <label style="display: block; margin-bottom: 10px;">Ban Duration:</label>
            <select id="banDurationSelect" class="message-input" style="width: 100%; margin-bottom: 15px; padding: 12px;">
                <option value="5">5 minutes</option>
                <option value="15">15 minutes</option>
                <option value="30">30 minutes</option>
                <option value="60">1 hour</option>
                <option value="1440">1 day</option>
                <option value="10080">1 week</option>
                <option value="43200">1 month</option>
            </select>
            <div style="display: flex; gap: 10px;">
                <button id="confirmBanBtn" class="send-button" style="flex: 1; background: #dc2626;">Confirm Ban</button>
                <button id="cancelBanBtn" class="room-button" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize Firebase
        let db = null;
        let messagesUnsubscribe = null;
        
        try {
            if (typeof firebaseConfig !== 'undefined') {
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                window.db = db; // Expose db to window for profile page access
                console.log('Firebase connected successfully!');
            } else {
                console.warn('Firebase config not found. Using localStorage fallback.');
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            console.warn('Falling back to localStorage.');
        }
        
        // Private Room Variables
        let currentRoomCode = null;

        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const currentNameDisplay = document.getElementById('currentNameDisplay');
        const currentNameText = document.getElementById('currentNameText');
        const userNameContainer = document.getElementById('userNameContainer');
        
        // Dev star and modals
        const devStarButton = document.getElementById('devStarButton');
        const devPasswordModal = document.getElementById('devPasswordModal');
        const devPasswordInput = document.getElementById('devPasswordInput');
        const submitDevPassword = document.getElementById('submitDevPassword');
        const cancelDevPassword = document.getElementById('cancelDevPassword');
        const messageActionsModal = document.getElementById('messageActionsModal');
        const deleteMessageBtn = document.getElementById('deleteMessageBtn');
        const banUserBtn = document.getElementById('banUserBtn');
        const cancelMessageActions = document.getElementById('cancelMessageActions');
        const banDurationModal = document.getElementById('banDurationModal');
        const banDurationSelect = document.getElementById('banDurationSelect');
        const confirmBanBtn = document.getElementById('confirmBanBtn');
        const cancelBanBtn = document.getElementById('cancelBanBtn');
        const banUserInfo = document.getElementById('banUserInfo');
        const messageActionsUser = document.getElementById('messageActionsUser');
        
        let selectedMessageForAction = null;
        let selectedUserForBan = null;
        const DEV_PASSWORD = 'testtypetexthereSACbzn1234567890=-09090909009mt9-9=0DevBlockPasswordistohardtoguesswhywhywhy???><><2323tteessttlongpassword75shdsdhidshueew8iugjhlkghdffposdiavkhjxdbfkjs;go;sdpbtspodgp;dsg(-_-)';
        
        // Room UI elements
        const createRoomButton = document.getElementById('createRoomButton');
        const joinRoomButton = document.getElementById('joinRoomButton');
        const leaveRoomButton = document.getElementById('leaveRoomButton');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const currentRoomCodeDisplay = document.getElementById('currentRoomCodeDisplay');
        const roomCodeModal = document.getElementById('roomCodeModal');
        const roomCodeDisplayText = document.getElementById('roomCodeDisplayText');
        const copyRoomCodeButton = document.getElementById('copyRoomCodeButton');
        const closeRoomCodeModal = document.getElementById('closeRoomCodeModal');
        const joinRoomModal = document.getElementById('joinRoomModal');
        const roomCodeInput = document.getElementById('roomCodeInput');
        const confirmJoinButton = document.getElementById('confirmJoinButton');
        const cancelJoinButton = document.getElementById('cancelJoinButton');
        
        // Emoji and GIF picker elements
        const emojiButton = document.getElementById('emojiButton');
        const gifButton = document.getElementById('gifButton');
        const emojiPickerModal = document.getElementById('emojiPickerModal');
        const gifPickerModal = document.getElementById('gifPickerModal');
        const emojiGrid = document.getElementById('emojiGrid');
        const gifGrid = document.getElementById('gifGrid');
        const gifSearchInput = document.getElementById('gifSearchInput');
        const gifSearchButton = document.getElementById('gifSearchButton');
        const closeEmojiPicker = document.getElementById('closeEmojiPicker');
        const closeGifPicker = document.getElementById('closeGifPicker');
        
        // Giphy API key
        const GIPHY_API_KEY = 'Dhphjb15RHAVVMl43LwS3V73cS3oYj9J';

        let currentUserName = '';
        let loadedMessageIds = new Set(); // Track loaded messages to prevent duplicates
        const MAX_VISIBLE_MESSAGES = 35; // Maximum number of messages to display
        let isInitialLoad = true; // Track if this is the first load
        let selectedImage = null; // Store selected image as base64

        // Load saved name from profile only
        function loadUserName() {
            // Only check profile - no fallback to chat name input
            const profileData = localStorage.getItem('jnjUserProfile');
            if (profileData) {
                try {
                    const profile = JSON.parse(profileData);
                    // Use username if available, otherwise fallback to displayName
                    if (profile.username && profile.username.trim() !== '') {
                        currentUserName = profile.username.trim();
                        showNameDisplay();
                        enableChat();
                        return;
                    } else if (profile.displayName && profile.displayName.trim() !== '') {
                        currentUserName = profile.displayName.trim();
                        showNameDisplay();
                        enableChat();
                        return;
                    }
                } catch (e) {
                    console.error('Error loading profile:', e);
                }
            }
            
            // No profile - show message to create profile
            showNoProfileMessage();
            disableChat();
        }

        // Show current name display
        function showNameDisplay() {
            if (userNameContainer) {
                userNameContainer.style.display = 'block';
            }
            if (currentNameDisplay) {
                currentNameDisplay.style.display = 'flex';
            }
            if (currentNameText) {
                currentNameText.textContent = currentUserName;
            }
        }
        
        // Show message when no profile exists
        function showNoProfileMessage() {
            if (userNameContainer) {
                userNameContainer.style.display = 'block';
            }
            if (currentNameDisplay) {
                currentNameDisplay.style.display = 'flex';
            }
            if (currentNameText) {
                currentNameText.innerHTML = '<a href="profile.html" style="color: #4a9eff; text-decoration: underline;">Create a profile</a> to start chatting';
            }
        }

        // Enable chat input
        function enableChat() {
            messageInput.disabled = false;
            sendButton.disabled = false;
            document.getElementById('imageInput').disabled = false;
            emojiButton.disabled = false;
            gifButton.disabled = false;
            messageInput.placeholder = 'Type a message...';
        }

        // Disable chat input
        function disableChat() {
            messageInput.disabled = true;
            sendButton.disabled = true;
            document.getElementById('imageInput').disabled = true;
            emojiButton.disabled = true;
            gifButton.disabled = true;
            messageInput.placeholder = 'Enter your name above to start chatting...';
        }

        // Update room UI based on current room state
        function updateRoomUI() {
            if (currentRoomCode) {
                // In a room - show leave button and room code
                createRoomButton.style.display = 'none';
                joinRoomButton.style.display = 'none';
                leaveRoomButton.style.display = 'block';
                roomCodeDisplay.style.display = 'flex';
                currentRoomCodeDisplay.textContent = currentRoomCode;
            } else {
                // Not in a room - show create/join buttons
                createRoomButton.style.display = 'block';
                joinRoomButton.style.display = 'block';
                leaveRoomButton.style.display = 'none';
                roomCodeDisplay.style.display = 'none';
            }
        }
        
        // Load messages from Firestore or localStorage fallback
        function loadMessages() {
            // Check if user has a room code
            const savedRoom = localStorage.getItem('jjnChatRoomCode');
            if (savedRoom) {
                // Validate the saved room code
                checkRoomValidity(savedRoom).then((isValid) => {
                    if (!isValid) {
                        // Room expired or doesn't exist, clear it
                        currentRoomCode = null;
                        localStorage.removeItem('jjnChatRoomCode');
                        updateRoomUI();
                    } else {
                        currentRoomCode = savedRoom;
                    }
                    
                    // Update UI based on room state
                    updateRoomUI();
                    
                    // Check if dev chat and apply styling
                    checkDevChatOnLoad();
                    
                    // Update welcome message
                    const welcomeMsg = chatMessages.querySelector('.welcome-message');
                    if (welcomeMsg) {
                        if (currentRoomCode === 'devchat') {
                            welcomeMsg.classList.add('dev-welcome');
                            welcomeMsg.querySelector('.message-content').innerHTML = '<p>üîß Welcome to Dev Chat Room!</p><p style="margin-top: 10px; font-size: 14px; opacity: 0.8;">This is a secret developer chat room.</p>';
                        } else if (currentRoomCode) {
                            welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to Private Room ' + currentRoomCode + '!';
                        } else {
                            welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to JNJ Chat! Start a conversation below.';
                        }
                    }
                    
                    // Reload username from profile to ensure it's up to date
                    loadUserName();
                    
                    // Load messages
                    if (db) {
                        // Use Firestore with real-time updates
                        loadMessagesFromFirestore(currentRoomCode);
                    } else {
                        // Fallback to localStorage
                        const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                        // Filter by room code if in a room
                        let filteredMessages = messages;
                        if (currentRoomCode) {
                            filteredMessages = messages.filter(msg => msg.roomCode === currentRoomCode);
                        } else {
                            filteredMessages = messages.filter(msg => !msg.roomCode);
                        }
                        // Only show the most recent messages
                        const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                        recentMessages.forEach(msg => {
                            addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id);
                        });
                        scrollToBottom();
                    }
                }).catch((error) => {
                    console.error('Error validating saved room:', error);
                    // On error, default to public chat
                    currentRoomCode = null;
                    localStorage.removeItem('jjnChatRoomCode');
                    updateRoomUI();
                    
                    const welcomeMsg = chatMessages.querySelector('.welcome-message');
                    if (welcomeMsg) {
                        welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to JNJ Chat! Start a conversation below.';
                    }
                    
                    if (db) {
                        loadMessagesFromFirestore(null);
                    } else {
                        const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                        const filteredMessages = messages.filter(msg => !msg.roomCode);
                        const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                        recentMessages.forEach(msg => {
                            addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id);
                        });
                        scrollToBottom();
                    }
                });
            } else {
                // No saved room, load public chat
                currentRoomCode = null;
                updateRoomUI();
                
                const welcomeMsg = chatMessages.querySelector('.welcome-message');
                if (welcomeMsg) {
                    welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to JNJ Chat! Start a conversation below.';
                }
                
                if (db) {
                    loadMessagesFromFirestore(null);
                } else {
                    const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                    const filteredMessages = messages.filter(msg => !msg.roomCode);
                    const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                    recentMessages.forEach(msg => {
                        addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, null, null, msg.id);
                    });
                    scrollToBottom();
                }
            }
        }

        // Load messages from Firestore with real-time listener
        function loadMessagesFromFirestore(roomCode = null) {
            // Unsubscribe from previous listener
            if (messagesUnsubscribe) {
                messagesUnsubscribe();
            }
            
            // Clear existing messages (except welcome message) before loading
            const existingMessages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            existingMessages.forEach(msg => msg.remove());
            loadedMessageIds.clear();
            isInitialLoad = true;
            
            // Determine which collection to use
            const collection = roomCode ? 'roomMessages' : 'messages';
            let query = db.collection(collection);
            
            // If in a room, filter by room code first
            // Note: We don't use orderBy here to avoid requiring a composite index
            // We'll sort in memory instead
            if (roomCode) {
                query = query.where('roomCode', '==', roomCode);
            } else {
                query = query.orderBy('timestamp', 'desc').limit(MAX_VISIBLE_MESSAGES);
            }
            
            // Set up real-time listener that gets all current messages and then listens for changes
            messagesUnsubscribe = query.onSnapshot((querySnapshot) => {
                    // On initial load, clear and reload all messages
                    if (isInitialLoad) {
                        const messages = [];
                        querySnapshot.forEach((doc) => {
                            const data = doc.data();
                            // Double-check room code match for safety
                            if (roomCode) {
                                // Only include messages with matching room code
                                if (data.roomCode === roomCode) {
                                    messages.push({
                                        id: doc.id,
                                        user: data.user,
                                        message: data.message,
                                        timestamp: data.timestamp,
                                        image: data.image || null,
                                        gif: data.gif || null,
                                        avatar: data.avatar || null,
                                        avatarImage: data.avatarImage || null
                                    });
                                }
                            } else {
                                // Only include messages without roomCode in public chat
                                if (!data.roomCode) {
                                    messages.push({
                                        id: doc.id,
                                        user: data.user,
                                        message: data.message,
                                        timestamp: data.timestamp,
                                        image: data.image || null,
                                        gif: data.gif || null,
                                        avatar: data.avatar || null,
                                        avatarImage: data.avatarImage || null
                                    });
                                }
                            }
                        });
                        
                        // Sort by timestamp descending (newest first), then take most recent
                        messages.sort((a, b) => b.timestamp - a.timestamp);
                        const recentMessages = messages.slice(0, MAX_VISIBLE_MESSAGES);
                        
                        // Display messages in reverse order (oldest first)
                        recentMessages.reverse().forEach(msg => {
                            if (!loadedMessageIds.has(msg.id)) {
                                console.log('Loading message from initial load:', { user: msg.user, hasGif: !!msg.gif, gifUrl: msg.gif });
                                addMessageToChat(msg.user, msg.message || '', msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id);
                                loadedMessageIds.add(msg.id);
                            }
                        });
                        scrollToBottom();
                        isInitialLoad = false;
                        
                        // Setup message click handlers for dev users
                        setupMessageClickHandlers();
                    } else {
                        // After initial load, only process new changes
                        querySnapshot.docChanges().forEach((change) => {
                            if (change.type === 'added' && !loadedMessageIds.has(change.doc.id)) {
                                const data = change.doc.data();
                                console.log('New message received:', { 
                                    user: data.user, 
                                    message: data.message,
                                    hasImage: !!data.image, 
                                    hasGif: !!data.gif, 
                                    gifUrl: data.gif,
                                    fullData: data
                                });
                                // Double-check room code match
                                if (roomCode) {
                                    if (data.roomCode === roomCode) {
                                        addMessageToChat(data.user, data.message || '', data.timestamp, false, data.image || null, data.gif || null, data.avatar, data.avatarImage, change.doc.id);
                                        loadedMessageIds.add(change.doc.id);
                                    }
                                } else {
                                    // Only show messages without roomCode in public chat
                                    if (!data.roomCode) {
                                        addMessageToChat(data.user, data.message || '', data.timestamp, false, data.image || null, data.gif || null, data.avatar, data.avatarImage, change.doc.id);
                                        loadedMessageIds.add(change.doc.id);
                                    }
                                }
                            }
                        });
                        scrollToBottom();
                    }
                }, (error) => {
                    console.error('Error in real-time listener:', error);
                    console.error('Error code:', error.code, 'Error message:', error.message);
                    
                    // If it's an index error, try alternative query
                    if (error.code === 'failed-precondition' && roomCode) {
                        console.log('Index missing, trying alternative query...');
                        // Try getting all room messages and filtering in memory
                        db.collection('roomMessages')
                            .where('roomCode', '==', roomCode)
                            .get()
                            .then((querySnapshot) => {
                                const messages = [];
                                querySnapshot.forEach((doc) => {
                                    const data = doc.data();
                                    if (data.roomCode === roomCode) {
                                        messages.push({
                                            id: doc.id,
                                            user: data.user,
                                            message: data.message,
                                            timestamp: data.timestamp,
                                            image: data.image || null,
                                            gif: data.gif || null
                                        });
                                    }
                                });
                                // Sort by timestamp descending
                                messages.sort((a, b) => b.timestamp - a.timestamp);
                                // Take only the most recent
                                const recentMessages = messages.slice(0, MAX_VISIBLE_MESSAGES);
                                // Reverse to show oldest first
                                recentMessages.reverse();
                                recentMessages.forEach(msg => {
                                    if (!loadedMessageIds.has(msg.id)) {
                                        addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id);
                                        loadedMessageIds.add(msg.id);
                                    }
                                });
                                scrollToBottom();
                                
                                // Set up a simpler listener without orderBy
                                messagesUnsubscribe = db.collection('roomMessages')
                                    .where('roomCode', '==', roomCode)
                                    .onSnapshot((snapshot) => {
                                        snapshot.docChanges().forEach((change) => {
                                            if (change.type === 'added' && !loadedMessageIds.has(change.doc.id)) {
                                                const data = change.doc.data();
                                                console.log('Fallback listener - New message:', { user: data.user, hasGif: !!data.gif, gifUrl: data.gif, fullData: data });
                                                if (data.roomCode === roomCode) {
                                                    addMessageToChat(data.user, data.message || '', data.timestamp, false, data.image || null, data.gif || null, data.avatar, data.avatarImage, change.doc.id);
                                                    loadedMessageIds.add(change.doc.id);
                                                }
                                            }
                                        });
                                        scrollToBottom();
                                    });
                            })
                            .catch((fallbackError) => {
                                console.error('Fallback query also failed:', fallbackError);
                                // Final fallback to localStorage
                                const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                                let filteredMessages = messages.filter(msg => msg.roomCode === roomCode);
                                const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                                recentMessages.forEach(msg => {
                                    addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image || null, msg.gif || null, msg.avatar, msg.avatarImage, msg.id);
                                });
                                scrollToBottom();
                            });
                        return;
                    }
                    
                    // Fallback to localStorage
                    const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                    // Filter by room code if in a room
                    let filteredMessages = messages;
                    if (roomCode) {
                        filteredMessages = messages.filter(msg => msg.roomCode === roomCode);
                    } else {
                        filteredMessages = messages.filter(msg => !msg.roomCode);
                    }
                    // Only show the most recent messages
                    const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                    recentMessages.forEach(msg => {
                        addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image || null, msg.gif || null, msg.avatar, msg.avatarImage, msg.id);
                    });
                    scrollToBottom();
                });
        }

        // Save message to Firestore or localStorage fallback
        function saveMessage(user, message, timestamp, imageData = null, gifData = null, avatar = null, avatarImage = null) {
            const messageData = {
                user: user,
                message: message,
                timestamp: timestamp
            };
            
            if (imageData) {
                messageData.image = imageData;
            }
            
            if (gifData) {
                messageData.gif = gifData;
            }
            
            // Save avatar with message
            if (avatarImage) {
                messageData.avatarImage = avatarImage;
            } else if (avatar) {
                messageData.avatar = avatar;
            }
            
            // Log what we're saving
            console.log('Saving message to Firestore:', { 
                user: user, 
                hasImage: !!imageData, 
                hasGif: !!gifData, 
                hasAvatar: !!avatar, 
                hasAvatarImage: !!avatarImage,
                fullMessageData: messageData 
            });
            
            // Add room code if in a private room
            if (currentRoomCode) {
                messageData.roomCode = currentRoomCode;
            }
            
            if (db) {
                // Save to Firestore - use roomMessages collection if in a room
                const collection = currentRoomCode ? 'roomMessages' : 'messages';
                
                // Log exactly what we're sending to Firestore
                console.log('About to save to Firestore:', {
                    collection: collection,
                    messageDataKeys: Object.keys(messageData),
                    hasAvatar: 'avatar' in messageData,
                    hasAvatarImage: 'avatarImage' in messageData,
                    avatarValue: messageData.avatar,
                    avatarImageLength: messageData.avatarImage ? messageData.avatarImage.length : 0,
                    fullMessageData: messageData
                });
                
                db.collection(collection).add(messageData)
                .then((docRef) => {
                    console.log('Message saved successfully to', collection, 'with ID:', docRef.id);
                    // Verify what was actually saved by reading it back
                    docRef.get().then((doc) => {
                        const savedData = doc.data();
                        console.log('Verifying saved data:', {
                            hasAvatar: 'avatar' in savedData,
                            hasAvatarImage: 'avatarImage' in savedData,
                            savedKeys: Object.keys(savedData)
                        });
                    });
                    // Update the message element with the actual document ID
                    const messageElement = chatMessages.querySelector(`[data-message-id="temp-${timestamp}"]`);
                    if (messageElement) {
                        messageElement.setAttribute('data-message-id', docRef.id);
                    }
                })
                .catch((error) => {
                    console.error('Error saving message to Firestore:', error);
                    console.error('Error details:', error.code, error.message);
                    console.error('Message data that failed:', messageData);
                    // Fallback to localStorage
                    saveMessageToLocalStorage(user, message, timestamp, imageData, gifData, avatar, avatarImage);
                });
            } else {
                // Fallback to localStorage
                saveMessageToLocalStorage(user, message, timestamp, imageData, gifData, avatar, avatarImage);
            }
        }

        // Fallback: Save messages to localStorage
        function saveMessageToLocalStorage(user, message, timestamp, imageData = null, gifData = null, avatar = null, avatarImage = null) {
            const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
            const messageObj = { user, message, timestamp };
            if (imageData) {
                messageObj.image = imageData;
            }
            if (gifData) {
                messageObj.gif = gifData;
            }
            // Save avatar with message
            if (avatarImage) {
                messageObj.avatarImage = avatarImage;
            } else if (avatar) {
                messageObj.avatar = avatar;
            }
            // Add room code if in a private room
            if (currentRoomCode) {
                messageObj.roomCode = currentRoomCode;
            }
            messages.push(messageObj);
            // Keep only last 100 messages
            if (messages.length > 100) {
                messages.shift();
            }
            localStorage.setItem('jjnChatMessages', JSON.stringify(messages));
        }

        // Add message to chat display
        function addMessageToChat(user, message, timestamp, shouldSave = true, imageData = null, gifData = null, avatar = null, avatarImage = null, messageId = null) {
            // Remove welcome message if it exists
            const welcomeMsg = chatMessages.querySelector('.welcome-message');
            if (welcomeMsg) {
                welcomeMsg.remove();
            }

            if (shouldSave) {
                saveMessage(user, message, timestamp, imageData, gifData);
            }

            // Check if message already exists (prevent duplicates)
            const existingMessages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            for (let msg of existingMessages) {
                const msgTime = msg.getAttribute('data-timestamp');
                const msgUser = msg.querySelector('.message-user').textContent;
                const msgContent = msg.querySelector('.message-content p')?.textContent || '';
                const msgImage = msg.querySelector('.message-image');
                const msgGif = msg.querySelector('.message-gif');
                const hasImage = msgImage !== null;
                const hasGif = msgGif !== null;
                // Check if this is the same message (same timestamp, user, content, and media)
                if (msgTime == timestamp && msgUser === user && msgContent === message) {
                    // If both have the same media state (both have image, both have gif, both have neither)
                    if (hasImage === !!imageData && hasGif === !!gifData) {
                        return; // Message already exists, don't add duplicate
                    }
                }
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.setAttribute('data-timestamp', timestamp);
            // Add message ID for tracking
            if (messageId) {
                // Use provided message ID (from Firestore)
                messageDiv.setAttribute('data-message-id', messageId);
            } else if (shouldSave && db) {
                // We'll set this after saving, but for now use timestamp as ID
                messageDiv.setAttribute('data-message-id', 'temp-' + timestamp);
            }
            
            const time = new Date(timestamp);
            const timeString = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            let imageHtml = '';
            if (imageData) {
                const imageId = 'img-' + timestamp;
                imageHtml = `<div class="message-image"><img id="${imageId}" src="${imageData}" alt="Uploaded image" class="chat-image"></div>`;
            }
            
            let gifHtml = '';
            if (gifData) {
                const gifId = 'gif-' + timestamp;
                console.log('Displaying GIF:', { gifUrl: gifData, timestamp: timestamp, user: user });
                gifHtml = `<div class="message-gif"><img id="${gifId}" src="${gifData}" alt="GIF" class="chat-gif" onerror="console.error('GIF failed to load:', this.src)"></div>`;
            } else {
                console.log('No GIF data to display for message:', { user: user, timestamp: timestamp });
            }
            
            // Censor the message before displaying (in case it wasn't censored when saved)
            let censoredMessage = censorMessage(message);
            
            // Convert emoji codes in message to actual emojis (basic support)
            let messageHtml = censoredMessage ? escapeHtml(censoredMessage) : '';
            // Emojis are already Unicode, so they should display fine
            
            // Use avatar from message data (saved with message), or fallback to profile if it's the current user
            let userAvatar = avatar || 'üë§';
            let userAvatarImage = avatarImage || null;
            let displayUsername = user; // Default to the user value
            
            // If no avatar in message data, check if it's the current user and use their profile
            if (!avatar && !avatarImage) {
                try {
                    const profileData = localStorage.getItem('jnjUserProfile');
                    if (profileData) {
                        const profile = JSON.parse(profileData);
                        // Check if this message is from the current user (match by username or displayName)
                        if (user === profile.username || user === profile.displayName) {
                            // Use username for display if available
                            if (profile.username && profile.username.trim() !== '') {
                                displayUsername = profile.username.trim();
                            }
                            // Get avatar from profile
                            if (profile.avatarImage) {
                                userAvatarImage = profile.avatarImage;
                            } else if (profile.avatar) {
                                userAvatar = profile.avatar;
                            }
                        }
                    }
                } catch (e) {
                    // Ignore errors
                }
            }
            
            // Create avatar HTML
            let avatarHtml = '';
            if (userAvatarImage) {
                // Base64 data URLs are safe to use directly (they come from profile or message data)
                avatarHtml = `<img src="${userAvatarImage}" alt="Avatar" class="message-avatar-image" style="width: 32px; height: 32px; border-radius: 50%; margin-right: 8px; object-fit: cover; border: 2px solid rgba(255, 255, 255, 0.2);">`;
            } else {
                // Emoji is safe to use directly
                avatarHtml = `<span class="message-avatar" style="font-size: 20px; margin-right: 8px;">${userAvatar}</span>`;
            }
            
            messageDiv.innerHTML = `
                <div class="message-header" style="display: flex; align-items: center; gap: 8px;">
                    ${avatarHtml}
                    <span class="message-user">${escapeHtml(displayUsername)}</span>
                    <span class="message-time" style="margin-left: auto;">${timeString}</span>
                </div>
                <div class="message-content">
                    ${imageHtml}
                    ${gifHtml}
                    ${messageHtml ? `<p>${messageHtml}</p>` : (imageHtml || gifHtml ? '' : '<p></p>')}
                </div>
            `;
            
            // Add click handler for image expansion
            if (imageData) {
                const imageId = 'img-' + timestamp;
                const img = messageDiv.querySelector('#' + imageId);
                if (img) {
                    img.addEventListener('click', function() {
                        expandImage(this);
                    });
                }
            }
            
            // Add click handler for GIF expansion
            if (gifData) {
                const gifId = 'gif-' + timestamp;
                const gif = messageDiv.querySelector('#' + gifId);
                if (gif) {
                    gif.addEventListener('click', function() {
                        expandImage(this);
                    });
                }
            }
            
            // Insert message in correct chronological order
            const allMessages = Array.from(chatMessages.querySelectorAll('.message:not(.welcome-message)'));
            let inserted = false;
            for (let i = 0; i < allMessages.length; i++) {
                const msgTimestamp = parseInt(allMessages[i].getAttribute('data-timestamp') || '0');
                if (timestamp < msgTimestamp) {
                    chatMessages.insertBefore(messageDiv, allMessages[i]);
                    inserted = true;
                    break;
                }
            }
            if (!inserted) {
                chatMessages.appendChild(messageDiv);
            }
            
            // Setup click handlers for dev users
            if (isDev()) {
                messageDiv.addEventListener('click', handleMessageClick);
                messageDiv.style.cursor = 'pointer';
                messageDiv.title = 'Click to moderate (Dev only)';
            }
            
            // Remove old messages if we exceed the limit
            limitVisibleMessages();
            
            scrollToBottom();
        }

        // Limit visible messages to MAX_VISIBLE_MESSAGES
        function limitVisibleMessages() {
            const allMessages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            if (allMessages.length > MAX_VISIBLE_MESSAGES) {
                // Remove the oldest messages (first ones in the list)
                const messagesToRemove = allMessages.length - MAX_VISIBLE_MESSAGES;
                for (let i = 0; i < messagesToRemove; i++) {
                    allMessages[i].remove();
                }
            }
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Scroll to bottom of chat
        function scrollToBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // Update all displayed messages with new username
        function updateChatMessagesUsername(oldUsername, oldDisplayName, newUsername) {
            // Get current user's profile to identify their messages
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (!profileData) return;
                
                const profile = JSON.parse(profileData);
                const currentUsername = profile.username || profile.displayName;
                
                // Update all message elements in the chat
                const messageElements = chatMessages.querySelectorAll('.message');
                messageElements.forEach(msgEl => {
                    const userSpan = msgEl.querySelector('.message-user');
                    if (userSpan) {
                        const currentText = userSpan.textContent.trim();
                        // Check if this message is from the current user
                        if (currentText === oldUsername || currentText === oldDisplayName) {
                            userSpan.textContent = newUsername;
                        }
                    }
                });
                
                // Also update currentUserName if it matches
                if (currentUserName === oldUsername || currentUserName === oldDisplayName) {
                    currentUserName = newUsername;
                    if (currentNameText) {
                        currentNameText.textContent = newUsername;
                    }
                }
            } catch (e) {
                console.error('Error updating chat messages:', e);
            }
        }
        
        // Update Firestore messages with new username
        function updateFirestoreMessagesUsername(oldUsername, oldDisplayName, newUsername) {
            if (!db) return;
            
            // Update public messages
            updateFirestoreCollection('messages', oldUsername, oldDisplayName, newUsername);
            // Update room messages
            updateFirestoreCollection('roomMessages', oldUsername, oldDisplayName, newUsername);
        }
        
        function updateFirestoreCollection(collectionName, oldUsername, oldDisplayName, newUsername) {
            if (!db) return;
            
            const collection = db.collection(collectionName);
            
            // Update messages with old username
            if (oldUsername) {
                collection.where('user', '==', oldUsername).get()
                    .then(querySnapshot => {
                        if (querySnapshot.empty) return;
                        const batch = db.batch();
                        let updateCount = 0;
                        querySnapshot.forEach(doc => {
                            batch.update(doc.ref, { user: newUsername });
                            updateCount++;
                        });
                        if (updateCount > 0) {
                            return batch.commit().then(() => {
                                console.log(`Updated ${updateCount} ${collectionName} messages from ${oldUsername} to ${newUsername}`);
                            });
                        }
                    })
                    .catch(error => {
                        console.error(`Error updating ${collectionName} messages:`, error);
                    });
            }
            
            // Update messages with old displayName (if different from username)
            if (oldDisplayName && oldDisplayName !== oldUsername) {
                collection.where('user', '==', oldDisplayName).get()
                    .then(querySnapshot => {
                        if (querySnapshot.empty) return;
                        const batch2 = db.batch();
                        let updateCount2 = 0;
                        querySnapshot.forEach(doc => {
                            batch2.update(doc.ref, { user: newUsername });
                            updateCount2++;
                        });
                        if (updateCount2 > 0) {
                            return batch2.commit().then(() => {
                                console.log(`Updated ${updateCount2} ${collectionName} messages from ${oldDisplayName} to ${newUsername}`);
                            });
                        }
                    })
                    .catch(error => {
                        console.error(`Error updating ${collectionName} messages:`, error);
                    });
            }
        }
        
        // Expose functions to profile page
        window.updateChatMessagesUsername = updateChatMessagesUsername;
        window.updateFirestoreMessagesUsername = updateFirestoreMessagesUsername;

        // Profanity filter - list of bad words (case-insensitive)
        const badWords = [
            'damn', 'hell', 'crap', 'stupid', 'idiot', 'dumb', 'shut up', 'shutup',
            'hate', 'kill', 'die', 'moron', 'loser', 'ugly', 'fat',
            // Profanity
            'fuck', 'fucking', 'fucked', 'fucker', 'fuckers',
            'shit', 'shitting', 'shitted',
            'ass', 'asses', 'asshole', 'assholes',
            'bitch', 'bitches', 'bitching',
            'bastard', 'bastards',
            'piss', 'pissing', 'pissed',
            'damn', 'damned', 'damnit', 'dammit',
            'crap', 'crappy',
            'dick', 'dicks',
            'cock', 'cocks',
            'pussy', 'pussies',
            'whore', 'whores',
            'slut', 'sluts',
            'nigger', 'niggers', 'nigga', 'niggas',
            'retard', 'retarded', 'retards',
            'gay', 'fag', 'fags', 'faggot', 'faggots',
            'cunt', 'cunts',
            'douche', 'douchebag', 'douchebags',
            'screw', 'screwed', 'screwing',
            'suck', 'sucks', 'sucking', 'sucked',
            'bullshit', 'bullshitting',
            'motherfucker', 'motherfuckers',
            'son of a bitch', 'sonofabitch',
            // Add more words as needed
        ];

        // Function to censor bad words in a message
        function censorMessage(message) {
            if (!message || typeof message !== 'string') return message;
            
            let censoredMessage = message;
            const replacement = 'kind word';
            
            // Create regex patterns for each bad word (case-insensitive, word boundaries)
            badWords.forEach(badWord => {
                // Escape special regex characters
                const escapedWord = badWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Match whole words only (case-insensitive)
                const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
                censoredMessage = censoredMessage.replace(regex, replacement);
            });
            
            return censoredMessage;
        }

        // Send message
        function sendMessage() {
            let message = messageInput.value.trim();
            if ((message === '' && !selectedImage && !selectedGif) || !currentUserName) return;

            // Check for chat code secret: "JNJ2025"
            if (message.toLowerCase() === 'jnj2025' && window.secretPages) {
                if (window.secretPages.unlock('chatcode')) {
                    // Redirect is handled in unlockSecret
                } else if (window.secretPages.isUnlocked('chatcode')) {
                    window.location.href = 'secrets.html';
                }
                messageInput.value = '';
                return;
            }

            // Always get the latest username and avatar from profile FIRST
            let messageUsername = currentUserName;
            let messageAvatar = 'üë§';
            let messageAvatarImage = null;
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (profileData) {
                    const profile = JSON.parse(profileData);
                    // Use username if available, otherwise use displayName
                    if (profile.username && profile.username.trim() !== '') {
                        messageUsername = profile.username.trim();
                        // Update currentUserName to keep it in sync
                        currentUserName = messageUsername;
                    } else if (profile.displayName && profile.displayName.trim() !== '') {
                        messageUsername = profile.displayName.trim();
                        currentUserName = messageUsername;
                    }
                    // Get avatar
                    if (profile.avatarImage) {
                        messageAvatarImage = profile.avatarImage;
                    } else if (profile.avatar) {
                        messageAvatar = profile.avatar;
                    }
                }
            } catch (e) {
                // Ignore errors, use currentUserName
            }
            
            // Check if user is banned (after getting username)
            if (isUserBanned(messageUsername)) {
                alert('You are banned from chatting. Please wait until the ban expires.');
                return;
            }
            
            // Censor the message before sending
            message = censorMessage(message);

            const timestamp = Date.now();
            const imageData = selectedImage;
            const gifData = selectedGif;
            
            // Clear image preview
            if (selectedImage) {
                selectedImage = null;
                document.getElementById('imagePreview').style.display = 'none';
                document.getElementById('previewImage').src = '';
                document.getElementById('imageInput').value = '';
            }
            
            // Clear GIF preview
            if (selectedGif) {
                selectedGif = null;
                document.getElementById('gifPreview').style.display = 'none';
                document.getElementById('previewGif').src = '';
            }
            
            console.log('Sending message:', { user: messageUsername, message: message, hasImage: !!imageData, hasGif: !!gifData, gifUrl: gifData, avatar: messageAvatar, avatarImage: !!messageAvatarImage });
            
            if (db) {
                // Save to Firestore first
                saveMessage(messageUsername, message || '', timestamp, imageData, gifData, messageAvatar, messageAvatarImage);
                
                // Add to display immediately for better UX
                addMessageToChat(messageUsername, message || '', timestamp, false, imageData, gifData, messageAvatar, messageAvatarImage);
            } else {
                addMessageToChat(messageUsername, message || '', timestamp, true, imageData, gifData, messageAvatar, messageAvatarImage);
            }
            messageInput.value = '';
            messageInput.focus();
        }
        
        let selectedGif = null; // Store selected GIF URL
        
        // Handle image selection
        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Check file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                alert('Image is too large! Maximum size is 5MB.');
                event.target.value = '';
                return;
            }
            
            // Check if it's an image
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file.');
                event.target.value = '';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                selectedImage = e.target.result; // Store as base64
                document.getElementById('previewImage').src = selectedImage;
                document.getElementById('imagePreview').style.display = 'flex';
            };
            reader.readAsDataURL(file);
        }
        
        // Remove selected image
        function removeImage() {
            selectedImage = null;
            document.getElementById('imagePreview').style.display = 'none';
            document.getElementById('previewImage').src = '';
            document.getElementById('imageInput').value = '';
        }
        
        // Expand image on click
        function expandImage(imgElement) {
            // Remove any existing expanded image
            const existingExpanded = document.querySelector('.expanded-image-overlay');
            if (existingExpanded) {
                existingExpanded.remove();
            }
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'expanded-image-overlay';
            overlay.innerHTML = `
                <div class="expanded-image-container">
                    <button class="close-expanded-image">‚úï</button>
                    <img src="${imgElement.src}" alt="Expanded image" class="expanded-image">
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay || e.target.classList.contains('close-expanded-image')) {
                    overlay.remove();
                }
            });
            
            // Close on Escape key
            const closeHandler = (e) => {
                if (e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', closeHandler);
                }
            };
            document.addEventListener('keydown', closeHandler);
        }

        // Save name handler

        // Generate a 6-digit room code
        function generateRoomCode() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }
        
        // Create a private room
        function createRoom() {
            if (!currentUserName) {
                alert('Please enter your name first.');
                return;
            }
            
            const roomCode = generateRoomCode();
            const roomCreationTime = Date.now();
            currentRoomCode = roomCode;
            localStorage.setItem('jjnChatRoomCode', roomCode);
            
            // Save room metadata to Firestore
            if (db) {
                db.collection('rooms').doc(roomCode).set({
                    code: roomCode,
                    createdAt: roomCreationTime,
                    createdBy: currentUserName
                }, { merge: false })
                .then(() => {
                    console.log('Room created successfully:', roomCode, 'at', new Date(roomCreationTime));
                })
                .catch((error) => {
                    console.error('Error creating room:', error);
                });
            } else {
                // Fallback: save to localStorage
                const rooms = JSON.parse(localStorage.getItem('jjnChatRooms') || '{}');
                rooms[roomCode] = {
                    code: roomCode,
                    createdAt: roomCreationTime,
                    createdBy: currentUserName
                };
                localStorage.setItem('jjnChatRooms', JSON.stringify(rooms));
                console.log('Room saved to localStorage:', roomCode, 'at', new Date(roomCreationTime));
            }
            
            // Update UI
            updateRoomUI();
            
            // Show modal with code to copy
            roomCodeDisplayText.textContent = roomCode;
            roomCodeModal.style.display = 'flex';
            
            // Clear chat and show welcome message for private room
            chatMessages.innerHTML = '<div class="message welcome-message"><div class="message-content"><p>Welcome to Private Room ' + roomCode + '!</p></div></div>';
            loadedMessageIds.clear();
            isInitialLoad = true;
            
            // Load messages for this room (will be empty initially)
            if (db) {
                loadMessagesFromFirestore(roomCode);
            } else {
                // Fallback: reload from localStorage with room filter
                loadMessages();
            }
        }
        
        // Join a private room
        function joinRoom() {
            if (!currentUserName) {
                alert('Please enter your name first.');
                return;
            }
            
            joinRoomModal.style.display = 'flex';
            roomCodeInput.focus();
        }
        
        // Confirm join room
        function confirmJoin() {
            const code = roomCodeInput.value.trim().toLowerCase();
            
            // Special dev code: 000001 redirects to dev secrets page
            if (code === '000001') {
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
                window.location.href = 'dev-secrets.html';
                return;
            }
            
            // Special dev chat room code: "bzn mt" or "bznmt"
            if (code === 'bzn mt' || code === 'bznmt') {
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
                
                // Join the dev chat room
                currentRoomCode = 'devchat';
                localStorage.setItem('jjnChatRoomCode', 'devchat');
                
                // Apply dev chat styling
                document.body.classList.add('dev-chat-active');
                const chatContainer = document.getElementById('chatContainer');
                const chatHeader = document.getElementById('chatHeader');
                const chatTitle = document.getElementById('chatTitle');
                if (chatContainer) chatContainer.classList.add('dev-chat');
                if (chatHeader) chatHeader.classList.add('dev-chat-header');
                if (chatTitle) chatTitle.textContent = 'üîß Dev Chat';
                
                // Update UI
                updateRoomUI();
                
                // Show dev star button
                showDevStarIfNeeded();
                
                // Clear chat and show welcome message for dev room
                chatMessages.innerHTML = '<div class="message welcome-message dev-welcome"><div class="message-content"><p>üîß Welcome to Dev Chat Room!</p><p style="margin-top: 10px; font-size: 14px; opacity: 0.8;">This is a secret developer chat room.</p></div></div>';
                loadedMessageIds.clear();
                isInitialLoad = true;
                
                // Load messages for dev room
                if (db) {
                    loadMessagesFromFirestore('devchat');
                } else {
                    // Fallback: reload from localStorage with room filter
                    loadMessages();
                }
                return;
            }
            
            // Regular room code validation (6 digits)
            if (code.length !== 6 || !/^\d+$/.test(code)) {
                alert('Please enter a valid 6-digit room code.');
                return;
            }
            
            // Show loading state
            const originalButtonText = confirmJoinButton.textContent;
            confirmJoinButton.textContent = 'Checking...';
            confirmJoinButton.disabled = true;
            
            // Check if room exists and is valid (created within past week)
            checkRoomValidity(code).then((isValid) => {
                confirmJoinButton.textContent = originalButtonText;
                confirmJoinButton.disabled = false;
                
                if (!isValid) {
                    alert('Room code not found or expired. Rooms expire after 7 days.');
                    roomCodeInput.value = '';
                    return;
                }
                
                // Room is valid, join it
                currentRoomCode = code;
                localStorage.setItem('jjnChatRoomCode', code);
                
                // Update UI
                updateRoomUI();
                
                // Close modal
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
                
                // Clear chat and show welcome message for private room
                chatMessages.innerHTML = '<div class="message welcome-message"><div class="message-content"><p>Welcome to Private Room ' + code + '!</p></div></div>';
                loadedMessageIds.clear();
                isInitialLoad = true;
                
                // Load messages for this room
                if (db) {
                    loadMessagesFromFirestore(code);
                } else {
                    // Fallback: reload from localStorage with room filter
                    loadMessages();
                }
            }).catch((error) => {
                console.error('Error checking room validity:', error);
                confirmJoinButton.textContent = originalButtonText;
                confirmJoinButton.disabled = false;
                alert('Error checking room code. Please try again.');
            });
        }
        
        // Check if a room code is valid (exists and was created within past week)
        function checkRoomValidity(roomCode, retryCount = 0) {
            const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000); // 7 days in milliseconds
            const maxRetries = 3;
            const retryDelay = 500; // 500ms delay between retries
            
            if (db) {
                // Check Firestore
                return db.collection('rooms').doc(roomCode).get()
                    .then((doc) => {
                        if (!doc.exists) {
                            // If room doesn't exist and we haven't retried, wait and try again
                            // This handles the case where room was just created but not yet saved
                            if (retryCount < maxRetries) {
                                console.log(`Room not found, retrying... (${retryCount + 1}/${maxRetries})`);
                                return new Promise((resolve) => {
                                    setTimeout(() => {
                                        checkRoomValidity(roomCode, retryCount + 1).then(resolve);
                                    }, retryDelay);
                                });
                            }
                            console.log('Room does not exist:', roomCode);
                            return false;
                        }
                        
                        const roomData = doc.data();
                        const createdAt = roomData.createdAt || 0;
                        
                        console.log('Room check:', {
                            code: roomCode,
                            createdAt: createdAt,
                            createdAtDate: new Date(createdAt),
                            oneWeekAgo: oneWeekAgo,
                            oneWeekAgoDate: new Date(oneWeekAgo),
                            isValid: createdAt >= oneWeekAgo,
                            timeDiff: Date.now() - createdAt,
                            timeDiffDays: (Date.now() - createdAt) / (24 * 60 * 60 * 1000)
                        });
                        
                        if (createdAt === 0) {
                            console.log('Room has no creation timestamp:', roomCode);
                            return false;
                        }
                        
                        if (createdAt < oneWeekAgo) {
                            console.log('Room expired:', roomCode, 'Created:', new Date(createdAt), 'Now:', new Date());
                            // Optionally delete expired room
                            db.collection('rooms').doc(roomCode).delete().catch(err => console.error('Error deleting expired room:', err));
                            return false;
                        }
                        
                        console.log('Room is valid:', roomCode, 'Created:', new Date(createdAt));
                        return true;
                    })
                    .catch((error) => {
                        console.error('Error checking room in Firestore:', error);
                        // Retry on error if we haven't exceeded max retries
                        if (retryCount < maxRetries) {
                            console.log(`Error checking room, retrying... (${retryCount + 1}/${maxRetries})`);
                            return new Promise((resolve) => {
                                setTimeout(() => {
                                    checkRoomValidity(roomCode, retryCount + 1).then(resolve);
                                }, retryDelay);
                            });
                        }
                        return false;
                    });
            } else {
                // Fallback: check localStorage
                return new Promise((resolve) => {
                    const rooms = JSON.parse(localStorage.getItem('jjnChatRooms') || '{}');
                    const room = rooms[roomCode];
                    
                    if (!room) {
                        console.log('Room does not exist in localStorage:', roomCode);
                        resolve(false);
                        return;
                    }
                    
                    const createdAt = room.createdAt || 0;
                    if (createdAt === 0) {
                        console.log('Room has no creation timestamp in localStorage:', roomCode);
                        resolve(false);
                        return;
                    }
                    
                    if (createdAt < oneWeekAgo) {
                        console.log('Room expired in localStorage:', roomCode);
                        // Remove expired room
                        delete rooms[roomCode];
                        localStorage.setItem('jjnChatRooms', JSON.stringify(rooms));
                        resolve(false);
                        return;
                    }
                    
                    console.log('Room is valid in localStorage:', roomCode);
                    resolve(true);
                });
            }
        }
        
        // Check if user is a dev
        function isDev() {
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (profileData) {
                    const profile = JSON.parse(profileData);
                    return profile.isDev === true;
                }
            } catch (e) {
                console.error('Error checking dev status:', e);
            }
            return false;
        }

        // Check if dev chat is active on page load
        function checkDevChatOnLoad() {
            if (currentRoomCode === 'devchat') {
                document.body.classList.add('dev-chat-active');
                const chatContainer = document.getElementById('chatContainer');
                const chatHeader = document.getElementById('chatHeader');
                const chatTitle = document.getElementById('chatTitle');
                if (chatContainer) chatContainer.classList.add('dev-chat');
                if (chatHeader) chatHeader.classList.add('dev-chat-header');
                if (chatTitle) chatTitle.textContent = 'üîß Dev Chat';
                
                // Show dev star button if user is not already a dev
                if (devStarButton) {
                    if (!isDev()) {
                        devStarButton.style.display = 'block';
                        console.log('Showing dev star button - user is not a dev');
                    } else {
                        devStarButton.style.display = 'none';
                        console.log('Hiding dev star button - user is already a dev');
                    }
                } else {
                    console.error('devStarButton element not found!');
                }
            } else {
                if (devStarButton) {
                    devStarButton.style.display = 'none';
                }
            }
        }
        
        // Also check when joining dev chat
        function showDevStarIfNeeded() {
            console.log('showDevStarIfNeeded called', { currentRoomCode, isDev: isDev(), devStarButton: !!devStarButton });
            if (currentRoomCode === 'devchat' && devStarButton) {
                if (!isDev()) {
                    devStarButton.style.display = 'block';
                    devStarButton.style.visibility = 'visible';
                    console.log('Showing dev star button - user is not a dev');
                } else {
                    devStarButton.style.display = 'none';
                    console.log('Hiding dev star button - user is already a dev');
                }
            }
        }
        
        // Handle dev star button click
        if (devStarButton) {
            devStarButton.addEventListener('click', () => {
                if (isDev()) {
                    alert('You are already a dev!');
                    return;
                }
                devPasswordModal.style.display = 'flex';
                devPasswordInput.focus();
            });
        }
        
        // Handle dev password submission
        function submitDevPasswordHandler() {
            const password = devPasswordInput.value.trim();
            if (password === DEV_PASSWORD) {
                // Save dev status to profile
                try {
                    const profileData = localStorage.getItem('jnjUserProfile');
                    let profile = {};
                    if (profileData) {
                        profile = JSON.parse(profileData);
                    }
                    profile.isDev = true;
                    localStorage.setItem('jnjUserProfile', JSON.stringify(profile));
                    
                    // Hide star button and close modal
                    devStarButton.style.display = 'none';
                    devPasswordModal.style.display = 'none';
                    devPasswordInput.value = '';
                    alert('‚≠ê Dev access granted! You now have moderation tools.');
                    
                    // Setup message handlers for newly granted dev
                    setupMessageClickHandlers();
                } catch (e) {
                    console.error('Error saving dev status:', e);
                    alert('Error saving dev status. Please try again.');
                }
            } else {
                alert('Incorrect password!');
                devPasswordInput.value = '';
                devPasswordInput.focus();
            }
        }
        
        if (submitDevPassword) {
            submitDevPassword.addEventListener('click', submitDevPasswordHandler);
        }
        
        if (devPasswordInput) {
            devPasswordInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitDevPasswordHandler();
                }
            });
        }
        
        // Cancel dev password modal
        if (cancelDevPassword) {
            cancelDevPassword.addEventListener('click', () => {
                devPasswordModal.style.display = 'none';
                devPasswordInput.value = '';
            });
        }
        
        // Handle message click for dev users
        function setupMessageClickHandlers() {
            if (!isDev()) return;
            
            const messages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            messages.forEach(msg => {
                // Remove existing handler to avoid duplicates
                msg.removeEventListener('click', handleMessageClick);
                msg.addEventListener('click', handleMessageClick);
                msg.style.cursor = 'pointer';
                msg.title = 'Click to moderate (Dev only)';
            });
        }
        
        function handleMessageClick(e) {
            if (!isDev()) return;
            
            const messageDiv = e.currentTarget;
            const messageId = messageDiv.getAttribute('data-message-id');
            const userSpan = messageDiv.querySelector('.message-user');
            const username = userSpan ? userSpan.textContent.trim() : 'Unknown';
            
            selectedMessageForAction = messageDiv;
            selectedUserForBan = username;
            
            messageActionsUser.textContent = `User: ${username}`;
            messageActionsModal.style.display = 'flex';
        }
        
        // Delete message
        if (deleteMessageBtn) {
            deleteMessageBtn.addEventListener('click', () => {
                if (!selectedMessageForAction || !isDev()) return;
                
                const messageId = selectedMessageForAction.getAttribute('data-message-id');
                const roomCode = currentRoomCode || null;
                const collection = roomCode ? 'roomMessages' : 'messages';
                
                console.log('Deleting message:', { messageId, roomCode, collection, hasDb: !!db });
                
                if (db && messageId && !messageId.startsWith('temp-')) {
                    // Delete from Firestore
                    const docRef = db.collection(collection).doc(messageId);
                    docRef.delete()
                        .then(() => {
                            console.log('Message deleted from Firestore successfully:', messageId);
                            selectedMessageForAction.remove();
                            messageActionsModal.style.display = 'none';
                        })
                        .catch(error => {
                            console.error('Error deleting message from Firestore:', error);
                            console.error('Error details:', error.code, error.message);
                            // Still remove from DOM even if Firestore delete fails
                            selectedMessageForAction.remove();
                            messageActionsModal.style.display = 'none';
                            alert('Message removed from view, but there was an error deleting from database. Error: ' + error.message);
                        });
                } else if (db && messageId && messageId.startsWith('temp-')) {
                    // Temp message - just remove from DOM
                    console.log('Removing temp message from DOM');
                    selectedMessageForAction.remove();
                    messageActionsModal.style.display = 'none';
                } else if (!db) {
                    // No Firestore - delete from localStorage
                    console.log('Deleting from localStorage (no Firestore)');
                    const timestamp = selectedMessageForAction.getAttribute('data-timestamp');
                    const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                    const filteredMessages = messages.filter(msg => {
                        if (roomCode) {
                            return !(msg.timestamp == timestamp && msg.roomCode === roomCode);
                        } else {
                            return !(msg.timestamp == timestamp && !msg.roomCode);
                        }
                    });
                    localStorage.setItem('jjnChatMessages', JSON.stringify(filteredMessages));
                    selectedMessageForAction.remove();
                    messageActionsModal.style.display = 'none';
                } else {
                    // No message ID - just remove from DOM
                    console.log('No message ID, removing from DOM only');
                    selectedMessageForAction.remove();
                    messageActionsModal.style.display = 'none';
                }
            });
        }
        
        // Ban user
        if (banUserBtn) {
            banUserBtn.addEventListener('click', () => {
                if (!selectedUserForBan || !isDev()) return;
                
                banUserInfo.textContent = `Ban user: ${selectedUserForBan}`;
                messageActionsModal.style.display = 'none';
                banDurationModal.style.display = 'flex';
            });
        }
        
        // Confirm ban
        if (confirmBanBtn) {
            confirmBanBtn.addEventListener('click', () => {
                if (!selectedUserForBan || !isDev()) return;
                
                const durationMinutes = parseInt(banDurationSelect.value);
                const banUntil = Date.now() + (durationMinutes * 60 * 1000);
                
                // Save ban to localStorage and Firestore
                const bans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                bans[selectedUserForBan] = {
                    bannedUntil: banUntil,
                    bannedBy: currentUserName,
                    bannedAt: Date.now()
                };
                localStorage.setItem('jnjChatBans', JSON.stringify(bans));
                
                // Also save to Firestore if available
                if (db) {
                    db.collection('bans').doc(selectedUserForBan).set({
                        bannedUntil: banUntil,
                        bannedBy: currentUserName,
                        bannedAt: Date.now()
                    }).catch(error => {
                        console.error('Error saving ban to Firestore:', error);
                    });
                }
                
                banDurationModal.style.display = 'none';
                alert(`User ${selectedUserForBan} has been banned for ${durationMinutes} minutes.`);
                
                // Remove all messages from banned user
                const userMessages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
                userMessages.forEach(msg => {
                    const userSpan = msg.querySelector('.message-user');
                    if (userSpan && userSpan.textContent.trim() === selectedUserForBan) {
                        msg.remove();
                    }
                });
            });
        }
        
        // Cancel message actions
        if (cancelMessageActions) {
            cancelMessageActions.addEventListener('click', () => {
                messageActionsModal.style.display = 'none';
                selectedMessageForAction = null;
                selectedUserForBan = null;
            });
        }
        
        // Cancel ban
        if (cancelBanBtn) {
            cancelBanBtn.addEventListener('click', () => {
                banDurationModal.style.display = 'none';
            });
        }
        
        // Check if user is banned before sending message
        function isUserBanned(username) {
            try {
                const bans = JSON.parse(localStorage.getItem('jnjChatBans') || '{}');
                const ban = bans[username];
                if (ban && ban.bannedUntil > Date.now()) {
                    return true;
                }
                // Also check Firestore
                if (db) {
                    db.collection('bans').doc(username).get().then(doc => {
                        if (doc.exists) {
                            const banData = doc.data();
                            if (banData.bannedUntil > Date.now()) {
                                return true;
                            }
                        }
                    });
                }
            } catch (e) {
                console.error('Error checking ban status:', e);
            }
            return false;
        }
        
        // Leave private room and return to public chat
        function leaveRoom() {
            if (!confirm('Leave this private room and return to public chat?')) {
                return;
            }
            
            // Remove dev chat styling if active
            document.body.classList.remove('dev-chat-active');
            const chatContainer = document.getElementById('chatContainer');
            const chatHeader = document.getElementById('chatHeader');
            const chatTitle = document.getElementById('chatTitle');
            if (chatContainer) chatContainer.classList.remove('dev-chat');
            if (chatHeader) chatHeader.classList.remove('dev-chat-header');
            if (chatTitle) chatTitle.textContent = 'JNJ Chat';
            
            currentRoomCode = null;
            localStorage.removeItem('jjnChatRoomCode');
            
            // Update UI
            updateRoomUI();
            
            // Clear chat and show welcome message for public chat
            chatMessages.innerHTML = '<div class="message welcome-message"><div class="message-content"><p>Welcome to JNJ Chat! Start a conversation below.</p></div></div>';
            loadedMessageIds.clear();
            isInitialLoad = true;
            
            // Load public messages
            if (db) {
                loadMessagesFromFirestore(null);
            } else {
                // Fallback: reload from localStorage
                loadMessages();
            }
        }
        
        // Copy room code to clipboard
        function copyRoomCode() {
            const code = roomCodeDisplayText.textContent;
            navigator.clipboard.writeText(code).then(() => {
                copyRoomCodeButton.textContent = '‚úì';
                copyRoomCodeButton.style.background = 'rgba(81, 207, 102, 0.3)';
                setTimeout(() => {
                    copyRoomCodeButton.textContent = 'üìã';
                    copyRoomCodeButton.style.background = '';
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = code;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                copyRoomCodeButton.textContent = '‚úì';
                setTimeout(() => {
                    copyRoomCodeButton.textContent = 'üìã';
                }, 2000);
            });
        }
        
        // Event listeners
        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        document.getElementById('imageInput').addEventListener('change', handleImageSelect);
        document.getElementById('removeImageButton').addEventListener('click', removeImage);
        document.getElementById('removeGifButton').addEventListener('click', () => {
            selectedGif = null;
            document.getElementById('gifPreview').style.display = 'none';
            document.getElementById('previewGif').src = '';
        });
        
        // Emoji picker
        const commonEmojis = ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú', 'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥', 'üòè', 'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ', '‚òπÔ∏è', 'üò£', 'üòñ', 'üò´', 'üò©', 'ü•∫', 'üò¢', 'üò≠', 'üò§', 'üò†', 'üò°', 'ü§¨', 'ü§Ø', 'üò≥', 'ü•µ', 'ü•∂', 'üò±', 'üò®', 'üò∞', 'üò•', 'üòì', 'ü§ó', 'ü§î', 'ü§≠', 'ü§´', 'ü§•', 'üò∂', 'üòê', 'üòë', 'üò¨', 'üôÑ', 'üòØ', 'üò¶', 'üòß', 'üòÆ', 'üò≤', 'ü•±', 'üò¥', 'ü§§', 'üò™', 'üòµ', 'ü§ê', 'ü•¥', 'ü§¢', 'ü§Æ', 'ü§ß', 'üò∑', 'ü§í', 'ü§ï', 'ü§ë', 'ü§†', 'üòà', 'üëø', 'üëπ', 'üë∫', 'ü§°', 'üí©', 'üëª', 'üíÄ', '‚ò†Ô∏è', 'üëΩ', 'üëæ', 'ü§ñ', 'üéÉ', 'üò∫', 'üò∏', 'üòπ', 'üòª', 'üòº', 'üòΩ', 'üôÄ', 'üòø', 'üòæ'];
        
        function initEmojiPicker() {
            emojiGrid.innerHTML = '';
            commonEmojis.forEach(emoji => {
                const emojiButton = document.createElement('button');
                emojiButton.className = 'emoji-item';
                emojiButton.textContent = emoji;
                emojiButton.title = emoji;
                emojiButton.addEventListener('click', () => {
                    const cursorPos = messageInput.selectionStart;
                    const textBefore = messageInput.value.substring(0, cursorPos);
                    const textAfter = messageInput.value.substring(cursorPos);
                    messageInput.value = textBefore + emoji + textAfter;
                    messageInput.focus();
                    messageInput.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);
                    emojiPickerModal.style.display = 'none';
                });
                emojiGrid.appendChild(emojiButton);
            });
        }
        
        // GIF picker functions
        async function loadGIFs(query = 'trending') {
            gifGrid.innerHTML = '<div class="gif-loading">Loading GIFs...</div>';
            
            // If no API key, use a fallback or show message
            if (GIPHY_API_KEY === 'YOUR_GIPHY_API_KEY') {
                gifGrid.innerHTML = '<div class="gif-error">Please add your Giphy API key in chat.html. Get one free at <a href="https://developers.giphy.com/" target="_blank">developers.giphy.com</a></div>';
                return;
            }
            
            try {
                let url;
                if (query === 'trending' || query === '') {
                    url = `https://api.giphy.com/v1/gifs/trending?api_key=${GIPHY_API_KEY}&limit=24&rating=g`;
                } else {
                    url = `https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=24&rating=g`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                gifGrid.innerHTML = '';
                
                if (data.data && data.data.length > 0) {
                    data.data.forEach(gif => {
                        const gifItem = document.createElement('div');
                        gifItem.className = 'gif-item';
                        const gifImg = document.createElement('img');
                        gifImg.src = gif.images.fixed_height_small.url;
                        gifImg.alt = gif.title || 'GIF';
                        gifImg.loading = 'lazy';
                        gifImg.addEventListener('click', () => {
                            selectedGif = gif.images.original.url;
                            console.log('GIF selected:', selectedGif);
                            document.getElementById('previewGif').src = selectedGif;
                            document.getElementById('gifPreview').style.display = 'flex';
                            gifPickerModal.style.display = 'none';
                            gifSearchInput.value = '';
                        });
                        gifItem.appendChild(gifImg);
                        gifGrid.appendChild(gifItem);
                    });
                } else {
                    gifGrid.innerHTML = '<div class="gif-error">No GIFs found. Try a different search.</div>';
                }
            } catch (error) {
                console.error('Error loading GIFs:', error);
                gifGrid.innerHTML = '<div class="gif-error">Error loading GIFs. Please check your API key.</div>';
            }
        }
        
        // Event listeners for emoji and GIF pickers
        emojiButton.addEventListener('click', () => {
            emojiPickerModal.style.display = 'flex';
            initEmojiPicker();
        });
        
        gifButton.addEventListener('click', () => {
            gifPickerModal.style.display = 'flex';
            loadGIFs('trending');
        });
        
        closeEmojiPicker.addEventListener('click', () => {
            emojiPickerModal.style.display = 'none';
        });
        
        closeGifPicker.addEventListener('click', () => {
            gifPickerModal.style.display = 'none';
            gifSearchInput.value = '';
        });
        
        gifSearchButton.addEventListener('click', () => {
            const query = gifSearchInput.value.trim();
            loadGIFs(query || 'trending');
        });
        
        gifSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const query = gifSearchInput.value.trim();
                loadGIFs(query || 'trending');
            }
        });
        
        emojiPickerModal.addEventListener('click', (e) => {
            if (e.target === emojiPickerModal) {
                emojiPickerModal.style.display = 'none';
            }
        });
        
        gifPickerModal.addEventListener('click', (e) => {
            if (e.target === gifPickerModal) {
                gifPickerModal.style.display = 'none';
                gifSearchInput.value = '';
            }
        });
        
        // Room event listeners
        createRoomButton.addEventListener('click', createRoom);
        joinRoomButton.addEventListener('click', joinRoom);
        leaveRoomButton.addEventListener('click', leaveRoom);
        copyRoomCodeButton.addEventListener('click', copyRoomCode);
        closeRoomCodeModal.addEventListener('click', () => {
            roomCodeModal.style.display = 'none';
        });
        confirmJoinButton.addEventListener('click', confirmJoin);
        cancelJoinButton.addEventListener('click', () => {
            joinRoomModal.style.display = 'none';
            roomCodeInput.value = '';
        });
        roomCodeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                confirmJoin();
            }
        });
        roomCodeModal.addEventListener('click', (e) => {
            if (e.target === roomCodeModal) {
                roomCodeModal.style.display = 'none';
            }
        });
        joinRoomModal.addEventListener('click', (e) => {
            if (e.target === joinRoomModal) {
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
            }
        });

        // Initialize on page load
        loadUserName();
        loadMessages();
        
        // Cursor Trail Effect - Smooth line effect
        const trails = [];
        const maxTrails = 50;
        let lastTime = 0;
        
        function createCursorTrail(x, y, delay = 0) {
            setTimeout(() => {
                const trail = document.createElement('div');
                trail.className = 'cursor-trail';
                trail.style.left = x + 'px';
                trail.style.top = y + 'px';
                trail.style.opacity = '0.6';
                document.body.appendChild(trail);
                
                requestAnimationFrame(() => {
                    trail.style.opacity = '0';
                    trail.style.transform = 'translate(-50%, -50%) scale(0.2)';
                });
                
                setTimeout(() => {
                    if (trail.parentNode) {
                        trail.remove();
                    }
                }, 800);
                
                trails.push(trail);
                if (trails.length > maxTrails) {
                    const oldTrail = trails.shift();
                    if (oldTrail && oldTrail.parentNode) {
                        oldTrail.remove();
                    }
                }
            }, delay);
        }
        
        let lastX = 0;
        let lastY = 0;
        let mouseX = 0;
        let mouseY = 0;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            const now = Date.now();
            const timeSinceLastTrail = now - lastTime;
            
            if (timeSinceLastTrail > 8) {
                const distance = Math.sqrt(
                    Math.pow(mouseX - lastX, 2) + Math.pow(mouseY - lastY, 2)
                );
                
                if (distance > 2) {
                    createCursorTrail(mouseX, mouseY);
                    lastX = mouseX;
                    lastY = mouseY;
                    lastTime = now;
                }
            }
        });
    </script>
</body>
</html>

