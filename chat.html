<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - JNJ Website</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="chat.css">
    <link rel="stylesheet" href="animated-background.css">
    <link rel="stylesheet" href="secret-pages.css">
    <script src="page-transitions.js" defer></script>
    <script src="secret-pages.js" defer></script>
    <script src="animated-background.js" defer></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <!-- Firebase Config -->
    <script src="firebase-config.js"></script>
    <script src="auth.js" defer></script>
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Back to Home</a>
    
    <div class="chat-container" id="chatContainer">
        <header class="chat-header" id="chatHeader">
            <h1 id="chatTitle">JNJ Chat</h1>
            <p class="chat-subtitle">Junhu Choi ‚Ä¢ Jaxon Croskey ‚Ä¢ Nathan DeLuca</p>
            <button id="devStarButton" class="dev-star-button" style="display: none; position: absolute; top: 10px; right: 10px; background: rgba(255, 215, 0, 0.2); border: 2px solid #ffd700; border-radius: 50%; width: 50px; height: 50px; font-size: 28px; cursor: pointer; z-index: 1000; transition: all 0.2s; color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8); box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);" title="Become a Dev">‚≠ê</button>
            <div class="room-controls">
                <button id="createRoomButton" class="room-button" style="display: none;">Create Private Room</button>
                <button id="joinRoomButton" class="room-button" style="display: none;">Join Room</button>
                <button id="leaveRoomButton" class="room-button room-button-leave" style="display: none;">Leave Room</button>
                <div id="roomCodeDisplay" class="room-code-display" style="display: none;">
                    <span>Room: <strong id="currentRoomCodeDisplay"></strong></span>
                </div>
            </div>
        </header>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message welcome-message">
                <div class="message-content">
                    <p>Welcome to JNJ Chat! Start a conversation below.</p>
                </div>
            </div>
        </div>
        
        <div class="chat-input-container">
            <div class="user-name-container" id="userNameContainer" style="display: none;">
                <div class="current-name-display" id="currentNameDisplay">
                    <span>Chatting as: <strong id="currentNameText"></strong></span>
                    <a href="profile.html" class="change-name-button" style="text-decoration: none;">Edit Profile</a>
                </div>
            </div>
            <div class="input-wrapper">
                <button id="emojiButton" class="emoji-button" title="Add Emoji">üòÄ</button>
                <input 
                    type="text" 
                    id="messageInput" 
                    class="message-input" 
                    placeholder="Type a message..."
                    autocomplete="off"
                    disabled
                >
                <button id="gifButton" class="gif-button" title="Add GIF">GIF</button>
                <label for="imageInput" class="image-upload-button" title="Upload Image">
                    üìÅ
                </label>
                <input 
                    type="file" 
                    id="imageInput" 
                    accept="image/*"
                    style="display: none;"
                    disabled
                >
                <button id="sendButton" class="send-button" disabled>Send</button>
            </div>
            <div id="imagePreview" class="image-preview" style="display: none;">
                <img id="previewImage" src="" alt="Preview">
                <button id="removeImageButton" class="remove-image-button">‚úï</button>
            </div>
            <div id="gifPreview" class="gif-preview" style="display: none;">
                <img id="previewGif" src="" alt="GIF Preview">
                <button id="removeGifButton" class="remove-image-button">‚úï</button>
            </div>
        </div>
    </div>

    <!-- Room Code Modal -->
    <div id="roomCodeModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Private Room Created!</h2>
            <p style="color: #b0b0b0; margin-bottom: 20px; text-align: center;">Share this code with your friends:</p>
            <div class="room-code-display-large">
                <span id="roomCodeDisplayText"></span>
                <button id="copyRoomCodeButton" class="copy-button" title="Copy code">üìã</button>
            </div>
            <button id="closeRoomCodeModal" class="modal-button" style="margin-top: 20px;">Close</button>
        </div>
    </div>

    <!-- Join Room Modal -->
    <div id="joinRoomModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Join Private Room</h2>
            <input type="text" id="roomCodeInput" placeholder="Enter room code..." maxlength="10">
            <div class="modal-buttons">
                <button id="confirmJoinButton" class="modal-button">Join</button>
                <button id="cancelJoinButton" class="modal-button modal-button-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Emoji Picker Modal -->
    <div id="emojiPickerModal" class="modal emoji-picker-modal" style="display: none;">
        <div class="modal-content emoji-picker-content">
            <h2>Choose an Emoji</h2>
            <div class="emoji-grid" id="emojiGrid"></div>
            <button id="closeEmojiPicker" class="modal-button" style="margin-top: 15px;">Close</button>
        </div>
    </div>

    <!-- GIF Picker Modal -->
    <div id="gifPickerModal" class="modal gif-picker-modal" style="display: none;">
        <div class="modal-content gif-picker-content">
            <h2>Search GIFs</h2>
            <div class="gif-search-wrapper">
                <input type="text" id="gifSearchInput" class="gif-search-input" placeholder="Search for GIFs...">
                <button id="gifSearchButton" class="gif-search-button">Search</button>
            </div>
            <div class="gif-grid" id="gifGrid">
                <div class="gif-loading">Loading trending GIFs...</div>
            </div>
            <button id="closeGifPicker" class="modal-button" style="margin-top: 15px;">Close</button>
        </div>
    </div>

    <!-- Dev Password Modal -->
    <div id="devPasswordModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <h2>‚≠ê Dev Access</h2>
            <p style="margin-bottom: 20px; opacity: 0.8;">Enter the dev password to unlock moderation tools:</p>
            <input type="password" id="devPasswordInput" class="message-input" placeholder="Enter password..." style="width: 100%; margin-bottom: 15px; padding: 12px;">
            <div style="display: flex; gap: 10px;">
                <button id="submitDevPassword" class="send-button" style="flex: 1;">Submit</button>
                <button id="cancelDevPassword" class="room-button" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Message Actions Modal (for dev users) -->
    <div id="messageActionsModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 400px;">
            <h2>Message Actions</h2>
            <p id="messageActionsUser" style="margin-bottom: 20px; opacity: 0.8;"></p>
            <button id="deleteMessageBtn" class="send-button" style="width: 100%; margin-bottom: 10px; background: #dc2626;">Delete Message</button>
            <button id="cancelMessageActions" class="room-button" style="width: 100%;">Cancel</button>
        </div>
    </div>


    <script>
        // Initialize Firebase
        let db = null;
        let messagesUnsubscribe = null;
        
        try {
            if (typeof firebaseConfig !== 'undefined') {
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                window.db = db; // Expose db to window for profile page access
                console.log('Firebase connected successfully!');
            } else {
                console.warn('Firebase config not found. Using localStorage fallback.');
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            console.warn('Falling back to localStorage.');
        }
        
        // Private Room Variables
        let currentRoomCode = null;

        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const currentNameDisplay = document.getElementById('currentNameDisplay');
        const currentNameText = document.getElementById('currentNameText');
        const userNameContainer = document.getElementById('userNameContainer');
        
        // Dev star and modals
        const devStarButton = document.getElementById('devStarButton');
        const devPasswordModal = document.getElementById('devPasswordModal');
        const devPasswordInput = document.getElementById('devPasswordInput');
        const submitDevPassword = document.getElementById('submitDevPassword');
        const cancelDevPassword = document.getElementById('cancelDevPassword');
        const messageActionsModal = document.getElementById('messageActionsModal');
        const deleteMessageBtn = document.getElementById('deleteMessageBtn');
        const cancelMessageActions = document.getElementById('cancelMessageActions');
        const messageActionsUser = document.getElementById('messageActionsUser');
        
        let selectedMessageForAction = null;
        const DEV_PASSWORD = 'testtypetexthereSACbzn1234567890=-09090909009mt9-9=0DevBlockPasswordistohardtoguesswhywhywhy???><><2323tteessttlongpassword75shdsdhidshueew8iugjhlkghdffposdiavkhjxdbfkjs;go;sdpbtspodgp;dsg(-_-)';
        
        // Room UI elements
        const createRoomButton = document.getElementById('createRoomButton');
        const joinRoomButton = document.getElementById('joinRoomButton');
        const leaveRoomButton = document.getElementById('leaveRoomButton');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const currentRoomCodeDisplay = document.getElementById('currentRoomCodeDisplay');
        const roomCodeModal = document.getElementById('roomCodeModal');
        const roomCodeDisplayText = document.getElementById('roomCodeDisplayText');
        const copyRoomCodeButton = document.getElementById('copyRoomCodeButton');
        const closeRoomCodeModal = document.getElementById('closeRoomCodeModal');
        const joinRoomModal = document.getElementById('joinRoomModal');
        const roomCodeInput = document.getElementById('roomCodeInput');
        const confirmJoinButton = document.getElementById('confirmJoinButton');
        const cancelJoinButton = document.getElementById('cancelJoinButton');
        
        // Emoji and GIF picker elements
        const emojiButton = document.getElementById('emojiButton');
        const gifButton = document.getElementById('gifButton');
        const emojiPickerModal = document.getElementById('emojiPickerModal');
        const gifPickerModal = document.getElementById('gifPickerModal');
        const emojiGrid = document.getElementById('emojiGrid');
        const gifGrid = document.getElementById('gifGrid');
        const gifSearchInput = document.getElementById('gifSearchInput');
        const gifSearchButton = document.getElementById('gifSearchButton');
        const closeEmojiPicker = document.getElementById('closeEmojiPicker');
        const closeGifPicker = document.getElementById('closeGifPicker');
        
        // Giphy API key
        const GIPHY_API_KEY = 'Dhphjb15RHAVVMl43LwS3V73cS3oYj9J';

        let currentUserName = '';
        let loadedMessageIds = new Set(); // Track loaded messages to prevent duplicates
        const MAX_VISIBLE_MESSAGES = 35; // Maximum number of messages to display
        let isInitialLoad = true; // Track if this is the first load
        let selectedImage = null; // Store selected image as base64
        
        // Titles system (same as profile)
        const TITLES = {
            'newbie': { name: 'Newbie', description: 'Just getting started' },
            'tech-wizard': { name: 'Tech Wizard', description: 'Master of code' },
            'early-bird': { name: 'Early Bird', description: 'Joined early' },
            'dev': { name: 'Developer', description: 'Site developer' },
            'veteran': { name: 'Veteran', description: 'Been here a while' },
            'chatterbox': { name: 'Chatterbox', description: 'Loves to chat' },
            'legend': { name: 'Legend', description: 'Ultimate achievement' }
        };
        
        // Get title name by ID
        function getTitleName(titleId) {
            return TITLES[titleId] ? TITLES[titleId].name : titleId;
        }
        
        // Check and unlock titles
        function checkTitleUnlocks(profile) {
            const newlyUnlocked = [];
            let unlockedTitles = profile.unlockedTitles || [];
            
            // Check newbie (first message)
            if (!unlockedTitles.includes('newbie')) {
                const messageCount = parseInt(localStorage.getItem('jnjMessageCount') || '0');
                if (messageCount >= 1) {
                    unlockedTitles.push('newbie');
                    newlyUnlocked.push('newbie');
                }
            }
            
            // Check tech-wizard (100 messages)
            if (!unlockedTitles.includes('tech-wizard')) {
                const messageCount = parseInt(localStorage.getItem('jnjMessageCount') || '0');
                if (messageCount >= 100) {
                    unlockedTitles.push('tech-wizard');
                    newlyUnlocked.push('tech-wizard');
                }
            }
            
            // Check early-bird
            if (!unlockedTitles.includes('early-bird') && profile.joinDate) {
                const joinDate = new Date(profile.joinDate);
                const earlyDate = new Date('2024-01-01');
                if (joinDate < earlyDate) {
                    unlockedTitles.push('early-bird');
                    newlyUnlocked.push('early-bird');
                }
            }
            
            // Check dev
            if (!unlockedTitles.includes('dev') && profile.isDev === true) {
                unlockedTitles.push('dev');
                newlyUnlocked.push('dev');
            }
            
            // Check veteran (30 days)
            if (!unlockedTitles.includes('veteran') && profile.joinDate) {
                const joinDate = new Date(profile.joinDate);
                const now = new Date();
                const daysSinceJoin = (now - joinDate) / (1000 * 60 * 60 * 24);
                if (daysSinceJoin >= 30) {
                    unlockedTitles.push('veteran');
                    newlyUnlocked.push('veteran');
                }
            }
            
            // Check chatterbox (500 messages)
            if (!unlockedTitles.includes('chatterbox')) {
                const messageCount = parseInt(localStorage.getItem('jnjMessageCount') || '0');
                if (messageCount >= 500) {
                    unlockedTitles.push('chatterbox');
                    newlyUnlocked.push('chatterbox');
                }
            }
            
            // Check legend (1000 messages + 60 days)
            if (!unlockedTitles.includes('legend') && profile.joinDate) {
                const messageCount = parseInt(localStorage.getItem('jnjMessageCount') || '0');
                const joinDate = new Date(profile.joinDate);
                const now = new Date();
                const daysSinceJoin = (now - joinDate) / (1000 * 60 * 60 * 24);
                if (messageCount >= 1000 && daysSinceJoin >= 60) {
                    unlockedTitles.push('legend');
                    newlyUnlocked.push('legend');
                }
            }
            
            if (newlyUnlocked.length > 0) {
                profile.unlockedTitles = unlockedTitles;
                localStorage.setItem('jnjUserProfile', JSON.stringify(profile));
                // Save to Firestore if authenticated
                if (window.authSystem && window.authSystem.isAuthenticated()) {
                    window.authSystem.saveUserData({ profile: profile }).catch(e => console.error('Error saving titles:', e));
                }
            }
            
            return newlyUnlocked;
        }

        // Load saved name from profile only
        function loadUserName() {
            // Only check profile - no fallback to chat name input
            const profileData = localStorage.getItem('jnjUserProfile');
            if (profileData) {
                try {
                    const profile = JSON.parse(profileData);
                    
                    // Generate userId for old profiles that don't have one
                    if (!profile.userId) {
                        // Generate a unique user ID (same function as in profile.html)
                        function generateUserId() {
                            return 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15);
                        }
                        profile.userId = generateUserId();
                        localStorage.setItem('jnjUserProfile', JSON.stringify(profile));
                        console.log('Generated userId for old profile in chat:', profile.userId);
                    }
                    
                    // Use username if available, otherwise fallback to displayName
                    if (profile.username && profile.username.trim() !== '') {
                        currentUserName = profile.username.trim();
                        showNameDisplay();
                        enableChat();
                        return;
                    } else if (profile.displayName && profile.displayName.trim() !== '') {
                        currentUserName = profile.displayName.trim();
                        showNameDisplay();
                        enableChat();
                        return;
                    }
                } catch (e) {
                    console.error('Error loading profile:', e);
                }
            }
            
            // No profile - show message to create profile
            showNoProfileMessage();
            disableChat();
        }

        // Show current name display
        function showNameDisplay() {
            if (userNameContainer) {
                userNameContainer.style.display = 'block';
            }
            if (currentNameDisplay) {
                currentNameDisplay.style.display = 'flex';
            }
            if (currentNameText) {
                currentNameText.textContent = currentUserName;
            }
        }
        
        // Show message when no profile exists
        function showNoProfileMessage() {
            if (userNameContainer) {
                userNameContainer.style.display = 'block';
            }
            if (currentNameDisplay) {
                currentNameDisplay.style.display = 'flex';
            }
            if (currentNameText) {
                currentNameText.innerHTML = '<a href="profile.html" style="color: #4a9eff; text-decoration: underline;">Create a profile</a> to start chatting';
            }
        }

        // Enable chat input
        function enableChat() {
            messageInput.disabled = false;
            messageInput.readOnly = false;
            sendButton.disabled = false;
            document.getElementById('imageInput').disabled = false;
            emojiButton.disabled = false;
            gifButton.disabled = false;
            messageInput.placeholder = 'Type a message...';
        }

        // Disable chat input
        function disableChat() {
            messageInput.disabled = true;
            sendButton.disabled = true;
            document.getElementById('imageInput').disabled = true;
            emojiButton.disabled = true;
            gifButton.disabled = true;
            messageInput.placeholder = 'Enter your name above to start chatting...';
        }

        // Update room UI based on current room state
        function updateRoomUI() {
            if (currentRoomCode) {
                // In a room - show leave button and room code
                createRoomButton.style.display = 'none';
                joinRoomButton.style.display = 'none';
                leaveRoomButton.style.display = 'block';
                roomCodeDisplay.style.display = 'flex';
                currentRoomCodeDisplay.textContent = currentRoomCode;
            } else {
                // Not in a room - show create/join buttons
                createRoomButton.style.display = 'block';
                joinRoomButton.style.display = 'block';
                leaveRoomButton.style.display = 'none';
                roomCodeDisplay.style.display = 'none';
            }
        }
        
        // Load messages from Firestore or localStorage fallback
        function loadMessages() {
            // Check if user has a room code
            const savedRoom = localStorage.getItem('jjnChatRoomCode');
            if (savedRoom) {
                // Validate the saved room code
                checkRoomValidity(savedRoom).then((isValid) => {
                    if (!isValid) {
                        // Room expired or doesn't exist, clear it
                        currentRoomCode = null;
                        localStorage.removeItem('jjnChatRoomCode');
                        updateRoomUI();
                    } else {
                        currentRoomCode = savedRoom;
                    }
                    
                    // Update UI based on room state
                    updateRoomUI();
                    
                    // Check if dev chat and apply styling
                    checkDevChatOnLoad();
                    
                    // Update welcome message
                    const welcomeMsg = chatMessages.querySelector('.welcome-message');
                    if (welcomeMsg) {
                        if (currentRoomCode === 'devchat') {
                            welcomeMsg.classList.add('dev-welcome');
                            welcomeMsg.querySelector('.message-content').innerHTML = '<p>üîß Welcome to Dev Chat Room!</p><p style="margin-top: 10px; font-size: 14px; opacity: 0.8;">This is a secret developer chat room.</p>';
                        } else if (currentRoomCode) {
                            welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to Private Room ' + currentRoomCode + '!';
                        } else {
                            welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to JNJ Chat! Start a conversation below.';
                        }
                    }
                    
                    // Reload username from profile to ensure it's up to date
                    loadUserName();
                    
                    // Load messages
                    if (db) {
                        // Use Firestore with real-time updates
                        loadMessagesFromFirestore(currentRoomCode);
                    } else {
                        // Fallback to localStorage
                        const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                        // Filter by room code if in a room, and exclude deleted messages
                        let filteredMessages = messages.filter(msg => !msg.deleted);
                        if (currentRoomCode) {
                            filteredMessages = filteredMessages.filter(msg => msg.roomCode === currentRoomCode);
                        } else {
                            filteredMessages = filteredMessages.filter(msg => !msg.roomCode);
                        }
                        // Only show the most recent messages
                        const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                        recentMessages.forEach(msg => {
                            addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id, msg.userId, msg.title, msg);
                        });
                        scrollToBottom();
                    }
                }).catch((error) => {
                    console.error('Error validating saved room:', error);
                    // On error, default to public chat
                    currentRoomCode = null;
                    localStorage.removeItem('jjnChatRoomCode');
                    updateRoomUI();
                    
                    const welcomeMsg = chatMessages.querySelector('.welcome-message');
                    if (welcomeMsg) {
                        welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to JNJ Chat! Start a conversation below.';
                    }
                    
                    if (db) {
                        loadMessagesFromFirestore(null);
                    } else {
                        const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                        const filteredMessages = messages.filter(msg => !msg.deleted && !msg.roomCode);
                        const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                        recentMessages.forEach(msg => {
                            addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id, msg.userId, msg.title, msg);
                        });
                        scrollToBottom();
                    }
                });
            } else {
                // No saved room, load public chat
                currentRoomCode = null;
                updateRoomUI();
                
                const welcomeMsg = chatMessages.querySelector('.welcome-message');
                if (welcomeMsg) {
                    welcomeMsg.querySelector('.message-content p').textContent = 'Welcome to JNJ Chat! Start a conversation below.';
                }
                
                if (db) {
                    loadMessagesFromFirestore(null);
                } else {
                    const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                    const filteredMessages = messages.filter(msg => !msg.deleted && !msg.roomCode);
                    const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                    recentMessages.forEach(msg => {
                        addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, null, null, msg.id, msg.userId);
                    });
                    scrollToBottom();
                }
            }
        }

        // Load messages from Firestore with real-time listener
        function loadMessagesFromFirestore(roomCode = null) {
            // Unsubscribe from previous listener
            if (messagesUnsubscribe) {
                messagesUnsubscribe();
            }
            
            // Clear existing messages (except welcome message) before loading
            const existingMessages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            existingMessages.forEach(msg => msg.remove());
            loadedMessageIds.clear();
            isInitialLoad = true;
            
            // Determine which collection to use
            const collection = roomCode ? 'roomMessages' : 'messages';
            let query = db.collection(collection);
            
            // If in a room, filter by room code first
            // Note: We don't use orderBy here to avoid requiring a composite index
            // We'll sort in memory instead
            if (roomCode) {
                query = query.where('roomCode', '==', roomCode);
            } else {
                query = query.orderBy('timestamp', 'desc').limit(MAX_VISIBLE_MESSAGES);
            }
            
            // Set up real-time listener that gets all current messages and then listens for changes
            // Use includeMetadataChanges to ensure we get all updates, including deletions
            messagesUnsubscribe = query.onSnapshot({ includeMetadataChanges: false }, (querySnapshot) => {
                    // On initial load, clear and reload all messages
                    if (isInitialLoad) {
                        const messages = [];
                        querySnapshot.forEach((doc) => {
                            const data = doc.data();
                            // Skip deleted messages
                            if (data.deleted === true) {
                                return;
                            }
                            // Double-check room code match for safety
                            if (roomCode) {
                                // Only include messages with matching room code
                                if (data.roomCode === roomCode) {
                                    messages.push({
                                        id: doc.id,
                                        user: data.user,
                                        message: data.message,
                                        timestamp: data.timestamp,
                                        image: data.image || null,
                                        gif: data.gif || null,
                                        avatar: data.avatar || null,
                                        avatarImage: data.avatarImage || null,
                                        userId: data.userId || null,
                                        title: data.title || null,
                                        data: data
                                    });
                                }
                            } else {
                                // Only include messages without roomCode in public chat
                                if (!data.roomCode) {
                                    messages.push({
                                        id: doc.id,
                                        user: data.user,
                                        message: data.message,
                                        timestamp: data.timestamp,
                                        image: data.image || null,
                                        gif: data.gif || null,
                                        avatar: data.avatar || null,
                                        avatarImage: data.avatarImage || null,
                                        userId: data.userId || null,
                                        title: data.title || null,
                                        data: data
                                    });
                                }
                            }
                        });
                        
                        // Sort by timestamp descending (newest first), then take most recent
                        messages.sort((a, b) => b.timestamp - a.timestamp);
                        const recentMessages = messages.slice(0, MAX_VISIBLE_MESSAGES);
                        
                        // Display messages in reverse order (oldest first)
                        recentMessages.reverse().forEach(msg => {
                            if (!loadedMessageIds.has(msg.id)) {
                                addMessageToChat(msg.user, msg.message || '', msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id, msg.userId, msg.title, msg.data);
                                loadedMessageIds.add(msg.id);
                            }
                        });
                        scrollToBottom();
                        isInitialLoad = false;
                        
                        // Setup message click handlers for dev users
                        setupMessageClickHandlers();
                    } else {
                        // After initial load, only process new changes
                        querySnapshot.docChanges().forEach((change) => {
                            const messageId = change.doc.id;
                            const data = change.doc.data();
                            
                            if (change.type === 'added' && !loadedMessageIds.has(messageId)) {
                                // Skip deleted messages
                                if (data.deleted === true) {
                                    return;
                                }
                                
                                // Mark as loaded IMMEDIATELY to prevent duplicate
                                loadedMessageIds.add(messageId);
                                
                                console.log('New message received:', { 
                                    user: data.user, 
                                    message: data.message,
                                    hasImage: !!data.image, 
                                    hasGif: !!data.gif, 
                                    gifUrl: data.gif,
                                    fullData: data
                                });
                                
                                // Double-check room code match
                                if (roomCode) {
                                    if (data.roomCode === roomCode) {
                                        addMessageToChat(data.user, data.message || '', data.timestamp, false, data.image || null, data.gif || null, data.avatar, data.avatarImage, messageId, data.userId, data.title, data);
                                    }
                                } else {
                                    // Only show messages without roomCode in public chat
                                    if (!data.roomCode) {
                                        addMessageToChat(data.user, data.message || '', data.timestamp, false, data.image || null, data.gif || null, data.avatar, data.avatarImage, messageId, data.userId, data.title, data);
                                    }
                                }
                            } else if (change.type === 'modified') {
                                // Message was updated (e.g., marked as deleted)
                                console.log('Message modified:', { messageId, deleted: data.deleted, roomCode: data.roomCode });
                                
                                // Always check for deleted flag first, regardless of room code
                                if (data.deleted === true) {
                                    // Remove deleted message from DOM immediately
                                    const messageElement = chatMessages.querySelector(`[data-message-id="${messageId}"]`);
                                    if (messageElement) {
                                        console.log('Removing deleted message from DOM:', messageId);
                                        messageElement.style.transition = 'opacity 0.3s';
                                        messageElement.style.opacity = '0';
                                        setTimeout(() => {
                                            messageElement.remove();
                                        }, 300);
                                        loadedMessageIds.delete(messageId);
                                    } else {
                                        // Message not in DOM, but mark as deleted in loadedMessageIds
                                        loadedMessageIds.delete(messageId);
                                    }
                                } else {
                                    // Message was modified but not deleted
                                    // Check if message should be visible based on room code
                                    let shouldShow = false;
                                    if (roomCode) {
                                        shouldShow = data.roomCode === roomCode;
                                    } else {
                                        shouldShow = !data.roomCode;
                                    }
                                    
                                    if (shouldShow && !loadedMessageIds.has(messageId)) {
                                        // Message was modified but not deleted, and we haven't loaded it yet
                                        addMessageToChat(data.user, data.message || '', data.timestamp, false, data.image || null, data.gif || null, data.avatar, data.avatarImage, messageId, data.userId, data.title, data);
                                        loadedMessageIds.add(messageId);
                                    }
                                }
                            } else if (change.type === 'removed') {
                                // Message was actually deleted - remove it from DOM
                                const messageElement = chatMessages.querySelector(`[data-message-id="${messageId}"]`);
                                if (messageElement) {
                                    console.log('Removing deleted message from DOM:', messageId);
                                    messageElement.style.transition = 'opacity 0.3s';
                                    messageElement.style.opacity = '0';
                                    setTimeout(() => {
                                        messageElement.remove();
                                    }, 300);
                                    loadedMessageIds.delete(messageId);
                                }
                            }
                        });
                        
                        // Also check all current messages in snapshot for deleted flag (in case modified event was missed)
                        querySnapshot.forEach((doc) => {
                            const data = doc.data();
                            const docId = doc.id;
                            if (data.deleted === true && loadedMessageIds.has(docId)) {
                                const messageElement = chatMessages.querySelector(`[data-message-id="${docId}"]`);
                                if (messageElement) {
                                    console.log('Found deleted message in snapshot, removing:', docId);
                                    messageElement.style.transition = 'opacity 0.3s';
                                    messageElement.style.opacity = '0';
                                    setTimeout(() => {
                                        messageElement.remove();
                                    }, 300);
                                    loadedMessageIds.delete(docId);
                                }
                            }
                        });
                        
                        scrollToBottom();
                    }
                }, (error) => {
                    console.error('Error in real-time listener:', error);
                    console.error('Error code:', error.code, 'Error message:', error.message);
                    
                    // If it's an index error, try alternative query
                    if (error.code === 'failed-precondition' && roomCode) {
                        console.log('Index missing, trying alternative query...');
                        // Try getting all room messages and filtering in memory
                        db.collection('roomMessages')
                            .where('roomCode', '==', roomCode)
                            .get()
                            .then((querySnapshot) => {
                                const messages = [];
                                querySnapshot.forEach((doc) => {
                                    const data = doc.data();
                                    // Skip deleted messages
                                    if (data.deleted === true) {
                                        return;
                                    }
                                    if (data.roomCode === roomCode) {
                                        messages.push({
                                            id: doc.id,
                                            user: data.user,
                                            message: data.message,
                                            timestamp: data.timestamp,
                                            image: data.image || null,
                                            gif: data.gif || null
                                        });
                                    }
                                });
                                // Sort by timestamp descending
                                messages.sort((a, b) => b.timestamp - a.timestamp);
                                // Take only the most recent
                                const recentMessages = messages.slice(0, MAX_VISIBLE_MESSAGES);
                                // Reverse to show oldest first
                                recentMessages.reverse();
                                recentMessages.forEach(msg => {
                                    if (!loadedMessageIds.has(msg.id)) {
                                        addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image, msg.gif, msg.avatar, msg.avatarImage, msg.id, msg.userId, msg.title, msg);
                                        loadedMessageIds.add(msg.id);
                                    }
                                });
                                scrollToBottom();
                                
                                // Set up a simpler listener without orderBy
                                messagesUnsubscribe = db.collection('roomMessages')
                                    .where('roomCode', '==', roomCode)
                                    .onSnapshot({ includeMetadataChanges: false }, (snapshot) => {
                                        snapshot.docChanges().forEach((change) => {
                                            if (change.type === 'added' && !loadedMessageIds.has(change.doc.id)) {
                                                const data = change.doc.data();
                                                // Skip deleted messages
                                                if (data.deleted === true) {
                                                    return;
                                                }
                                                console.log('Fallback listener - New message:', { user: data.user, hasGif: !!data.gif, gifUrl: data.gif, fullData: data });
                                                if (data.roomCode === roomCode) {
                                                    addMessageToChat(data.user, data.message || '', data.timestamp, false, data.image || null, data.gif || null, data.avatar, data.avatarImage, change.doc.id, data.userId);
                                                    loadedMessageIds.add(change.doc.id);
                                                }
                                            } else if (change.type === 'modified') {
                                                // Message was updated (e.g., marked as deleted)
                                                const data = change.doc.data();
                                                const messageId = change.doc.id;
                                                
                                                // Check if message should be visible based on room code
                                                let shouldShow = false;
                                                if (roomCode) {
                                                    shouldShow = data.roomCode === roomCode;
                                                } else {
                                                    shouldShow = !data.roomCode;
                                                }
                                                
                                                if (data.deleted === true) {
                                                    // Remove deleted message from DOM
                                                    const messageElement = chatMessages.querySelector(`[data-message-id="${messageId}"]`);
                                                    if (messageElement) {
                                                        console.log('Fallback listener - Removing deleted message from DOM:', messageId);
                                                        messageElement.remove();
                                                        loadedMessageIds.delete(messageId);
                                                    }
                                                } else if (shouldShow && !loadedMessageIds.has(messageId)) {
                                                    // Message was modified but not deleted, and we haven't loaded it yet
                                                    addMessageToChat(data.user, data.message || '', data.timestamp, false, data.image || null, data.gif || null, data.avatar, data.avatarImage, messageId, data.userId, data.title, data);
                                                    loadedMessageIds.add(messageId);
                                                }
                                            } else if (change.type === 'removed') {
                                                // Message was actually deleted - remove it from DOM
                                                const messageId = change.doc.id;
                                                const messageElement = chatMessages.querySelector(`[data-message-id="${messageId}"]`);
                                                if (messageElement) {
                                                    console.log('Fallback listener - Removing deleted message from DOM:', messageId);
                                                    messageElement.remove();
                                                    loadedMessageIds.delete(messageId);
                                                }
                                            }
                                        });
                                        scrollToBottom();
                                    });
                            })
                            .catch((fallbackError) => {
                                console.error('Fallback query also failed:', fallbackError);
                                // Final fallback to localStorage
                                const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                                let filteredMessages = messages.filter(msg => msg.roomCode === roomCode);
                                const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                                recentMessages.forEach(msg => {
                                    addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image || null, msg.gif || null, msg.avatar, msg.avatarImage, msg.id);
                                });
                                scrollToBottom();
                            });
                        return;
                    }
                    
                    // Fallback to localStorage
                    const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                    // Filter by room code if in a room
                    let filteredMessages = messages;
                    if (roomCode) {
                        filteredMessages = messages.filter(msg => msg.roomCode === roomCode);
                    } else {
                        filteredMessages = messages.filter(msg => !msg.roomCode);
                    }
                    // Only show the most recent messages
                    const recentMessages = filteredMessages.slice(-MAX_VISIBLE_MESSAGES);
                    recentMessages.forEach(msg => {
                        addMessageToChat(msg.user, msg.message, msg.timestamp, false, msg.image || null, msg.gif || null, msg.avatar, msg.avatarImage, msg.id);
                    });
                    scrollToBottom();
                });
        }

        // Save message to Firestore or localStorage fallback
        function saveMessage(user, message, timestamp, imageData = null, gifData = null, avatar = null, avatarImage = null, userId = null, title = null) {
            const messageData = {
                user: user,
                message: message,
                timestamp: timestamp
            };
            
            // Add userId if provided
            if (userId) {
                messageData.userId = userId;
            }
            
            if (imageData) {
                messageData.image = imageData;
            }
            
            if (gifData) {
                messageData.gif = gifData;
            }
            
            // Save avatar with message
            if (avatarImage) {
                messageData.avatarImage = avatarImage;
            } else if (avatar) {
                messageData.avatar = avatar;
            }
            
            // Save title with message
            if (title) {
                messageData.title = title;
            }
            
            // Log what we're saving
            console.log('Saving message to Firestore:', { 
                user: user, 
                hasImage: !!imageData, 
                hasGif: !!gifData, 
                hasAvatar: !!avatar, 
                hasAvatarImage: !!avatarImage,
                fullMessageData: messageData 
            });
            
            // Add room code if in a private room
            if (currentRoomCode) {
                messageData.roomCode = currentRoomCode;
            }
            
            if (db) {
                // Save to Firestore - use roomMessages collection if in a room
                const collection = currentRoomCode ? 'roomMessages' : 'messages';
                
                // Log exactly what we're sending to Firestore
                console.log('About to save to Firestore:', {
                    collection: collection,
                    messageDataKeys: Object.keys(messageData),
                    hasAvatar: 'avatar' in messageData,
                    hasAvatarImage: 'avatarImage' in messageData,
                    avatarValue: messageData.avatar,
                    avatarImageLength: messageData.avatarImage ? messageData.avatarImage.length : 0,
                    fullMessageData: messageData
                });
                
                return db.collection(collection).add(messageData)
                .then((docRef) => {
                    console.log('Message saved successfully to', collection, 'with ID:', docRef.id);
                    // Mark as loaded immediately to prevent duplicate from listener
                    loadedMessageIds.add(docRef.id);
                    // Verify what was actually saved by reading it back
                    docRef.get().then((doc) => {
                        const savedData = doc.data();
                        console.log('Verifying saved data:', {
                            hasAvatar: 'avatar' in savedData,
                            hasAvatarImage: 'avatarImage' in savedData,
                            savedKeys: Object.keys(savedData)
                        });
                    });
                    // Return the message ID
                    return docRef.id;
                })
                .catch((error) => {
                    console.error('Error saving message to Firestore:', error);
                    console.error('Error details:', error.code, error.message);
                    console.error('Message data that failed:', messageData);
                    // Fallback to localStorage
                    saveMessageToLocalStorage(user, message, timestamp, imageData, gifData, avatar, avatarImage, userId, title);
                    return null;
                });
            } else {
                // Fallback to localStorage
                saveMessageToLocalStorage(user, message, timestamp, imageData, gifData, avatar, avatarImage, userId, title);
            }
        }

        // Fallback: Save messages to localStorage
        function saveMessageToLocalStorage(user, message, timestamp, imageData = null, gifData = null, avatar = null, avatarImage = null, userId = null, title = null) {
            const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
            const messageObj = { user, message, timestamp };
            if (imageData) {
                messageObj.image = imageData;
            }
            if (gifData) {
                messageObj.gif = gifData;
            }
            // Save avatar with message
            if (avatarImage) {
                messageObj.avatarImage = avatarImage;
            } else if (avatar) {
                messageObj.avatar = avatar;
            }
            // Save userId if provided
            if (userId) {
                messageObj.userId = userId;
            }
            // Save title if provided
            if (title) {
                messageObj.title = title;
            }
            // Add room code if in a private room
            if (currentRoomCode) {
                messageObj.roomCode = currentRoomCode;
            }
            messages.push(messageObj);
            // Keep only last 100 messages
            if (messages.length > 100) {
                messages.shift();
            }
            localStorage.setItem('jjnChatMessages', JSON.stringify(messages));
        }

        // Add message to chat display
        function addMessageToChat(user, message, timestamp, shouldSave = true, imageData = null, gifData = null, avatar = null, avatarImage = null, messageId = null, userId = null, title = null, messageData = null) {
            // Remove welcome message if it exists
            const welcomeMsg = chatMessages.querySelector('.welcome-message');
            if (welcomeMsg) {
                welcomeMsg.remove();
            }

            if (shouldSave) {
                saveMessage(user, message, timestamp, imageData, gifData);
            }

            // Check if message already exists (prevent duplicates)
            // First check by messageId if we have it
            if (messageId && loadedMessageIds.has(messageId)) {
                // Check if message is already in DOM
                const existingMsg = chatMessages.querySelector(`[data-message-id="${messageId}"]`);
                if (existingMsg) {
                    return; // Message already exists, don't add duplicate
                }
            }
            
            // Also check by timestamp + user + content (for cases where messageId might not match)
            const existingMessages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            for (let msg of existingMessages) {
                const msgTime = msg.getAttribute('data-timestamp');
                const msgUserSpan = msg.querySelector('.message-user');
                if (!msgUserSpan) continue;
                
                // Get username without title (title is in a separate span)
                let msgUser = msgUserSpan.textContent.trim();
                // Remove title if present (format: "Username [Title]")
                const titleMatch = msgUser.match(/^(.+?)\s*\[.+\]$/);
                if (titleMatch) {
                    msgUser = titleMatch[1].trim();
                }
                
                const msgContent = msg.querySelector('.message-content p')?.textContent || '';
                const msgImage = msg.querySelector('.message-image');
                const msgGif = msg.querySelector('.message-gif');
                const hasImage = msgImage !== null;
                const hasGif = msgGif !== null;
                
                // Check if this is the same message (same timestamp, user, content, and media)
                // Allow 1 second tolerance for timestamp (in case of slight timing differences)
                const timeDiff = Math.abs(parseInt(msgTime) - timestamp);
                if (timeDiff < 1000 && msgUser === user && msgContent === message) {
                    // If both have the same media state (both have image, both have gif, both have neither)
                    if (hasImage === !!imageData && hasGif === !!gifData) {
                        return; // Message already exists, don't add duplicate
                    }
                }
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.setAttribute('data-timestamp', timestamp);
            // Add userId as data attribute for banning
            if (userId) {
                messageDiv.setAttribute('data-user-id', userId);
            }
            // Add message ID for tracking
            if (messageId) {
                // Use provided message ID (from Firestore)
                messageDiv.setAttribute('data-message-id', messageId);
            } else if (shouldSave && db) {
                // We'll set this after saving, but for now use timestamp as ID
                messageDiv.setAttribute('data-message-id', 'temp-' + timestamp);
            }
            
            const time = new Date(timestamp);
            const timeString = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            let imageHtml = '';
            if (imageData) {
                const imageId = 'img-' + timestamp;
                imageHtml = `<div class="message-image"><img id="${imageId}" src="${imageData}" alt="Uploaded image" class="chat-image"></div>`;
            }
            
            let gifHtml = '';
            if (gifData) {
                const gifId = 'gif-' + timestamp;
                gifHtml = `<div class="message-gif"><img id="${gifId}" src="${gifData}" alt="GIF" class="chat-gif" onerror="console.error('GIF failed to load:', this.src)"></div>`;
            }
            
            // Censor the message before displaying (in case it wasn't censored when saved)
            let censoredMessage = censorMessage(message);
            
            // Convert emoji codes in message to actual emojis (basic support)
            let messageHtml = censoredMessage ? escapeHtml(censoredMessage) : '';
            // Emojis are already Unicode, so they should display fine
            
            // Use avatar from message data (saved with message), or fallback to profile if it's the current user
            let userAvatar = avatar || 'üë§';
            let userAvatarImage = avatarImage || null;
            let displayUsername = user; // Default to the user value
            let userTitle = null; // Title to display
            
            // Get user's profile to check for title
            // First, try to get title from messageData (saved with message)
            if (messageData && messageData.title) {
                userTitle = messageData.title;
            } else if (title) {
                // Title passed as parameter
                userTitle = title;
            }
            
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (profileData) {
                    const profile = JSON.parse(profileData);
                    // Check if this message is from the current user (match by username or displayName)
                    if (user === profile.username || user === profile.displayName || user === currentUserName) {
                        // Use username for display if available
                        if (profile.username && profile.username.trim() !== '') {
                            displayUsername = profile.username.trim();
                        }
                        // Get avatar from profile
                        if (profile.avatarImage) {
                            userAvatarImage = profile.avatarImage;
                        } else if (profile.avatar) {
                            userAvatar = profile.avatar;
                        }
                        // Get title from profile if not already set
                        if (!userTitle && profile.equippedTitle) {
                            userTitle = profile.equippedTitle;
                        }
                    }
                }
            } catch (e) {
                // Ignore errors
            }
            
            // Create avatar HTML
            let avatarHtml = '';
            if (userAvatarImage) {
                // Base64 data URLs are safe to use directly (they come from profile or message data)
                avatarHtml = `<img src="${userAvatarImage}" alt="Avatar" class="message-avatar-image" style="width: 32px; height: 32px; border-radius: 50%; margin-right: 8px; object-fit: cover; border: 2px solid rgba(255, 255, 255, 0.2);">`;
            } else {
                // Emoji is safe to use directly
                avatarHtml = `<span class="message-avatar" style="font-size: 20px; margin-right: 8px;">${userAvatar}</span>`;
            }
            
            // Title display (golden color)
            const titleHtml = userTitle ? ` <span style="color: #FFD700; font-weight: bold; font-size: 0.9em;">[${getTitleName(userTitle)}]</span>` : '';
            
            messageDiv.innerHTML = `
                <div class="message-header" style="display: flex; align-items: center; gap: 8px;">
                    ${avatarHtml}
                    <span class="message-user">${escapeHtml(displayUsername)}${titleHtml}</span>
                    <span class="message-time" style="margin-left: auto;">${timeString}</span>
                </div>
                <div class="message-content">
                    ${imageHtml}
                    ${gifHtml}
                    ${messageHtml ? `<p>${messageHtml}</p>` : (imageHtml || gifHtml ? '' : '<p></p>')}
                </div>
            `;
            
            // Add click handler for image expansion
            if (imageData) {
                const imageId = 'img-' + timestamp;
                const img = messageDiv.querySelector('#' + imageId);
                if (img) {
                    img.addEventListener('click', function() {
                        expandImage(this);
                    });
                }
            }
            
            // Add click handler for GIF expansion
            if (gifData) {
                const gifId = 'gif-' + timestamp;
                const gif = messageDiv.querySelector('#' + gifId);
                if (gif) {
                    gif.addEventListener('click', function() {
                        expandImage(this);
                    });
                }
            }
            
            // Insert message in correct chronological order
            const allMessages = Array.from(chatMessages.querySelectorAll('.message:not(.welcome-message)'));
            let inserted = false;
            for (let i = 0; i < allMessages.length; i++) {
                const msgTimestamp = parseInt(allMessages[i].getAttribute('data-timestamp') || '0');
                if (timestamp < msgTimestamp) {
                    chatMessages.insertBefore(messageDiv, allMessages[i]);
                    inserted = true;
                    break;
                }
            }
            if (!inserted) {
                chatMessages.appendChild(messageDiv);
            }
            
            // Setup click handlers for dev users
            if (isDev()) {
                messageDiv.addEventListener('click', handleMessageClick);
                messageDiv.style.cursor = 'pointer';
                messageDiv.title = 'Click to moderate (Dev only)';
            }
            
            // Remove old messages if we exceed the limit
            limitVisibleMessages();
            
            scrollToBottom();
        }

        // Limit visible messages to MAX_VISIBLE_MESSAGES
        function limitVisibleMessages() {
            const allMessages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            if (allMessages.length > MAX_VISIBLE_MESSAGES) {
                // Remove the oldest messages (first ones in the list)
                const messagesToRemove = allMessages.length - MAX_VISIBLE_MESSAGES;
                for (let i = 0; i < messagesToRemove; i++) {
                    allMessages[i].remove();
                }
            }
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Scroll to bottom of chat
        function scrollToBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // Update all displayed messages with new username
        function updateChatMessagesUsername(oldUsername, oldDisplayName, newUsername) {
            // Get current user's profile to identify their messages
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (!profileData) return;
                
                const profile = JSON.parse(profileData);
                const currentUsername = profile.username || profile.displayName;
                
                // Update all message elements in the chat
                const messageElements = chatMessages.querySelectorAll('.message');
                messageElements.forEach(msgEl => {
                    const userSpan = msgEl.querySelector('.message-user');
                    if (userSpan) {
                        const currentText = userSpan.textContent.trim();
                        // Check if this message is from the current user
                        if (currentText === oldUsername || currentText === oldDisplayName) {
                            userSpan.textContent = newUsername;
                        }
                    }
                });
                
                // Also update currentUserName if it matches
                if (currentUserName === oldUsername || currentUserName === oldDisplayName) {
                    currentUserName = newUsername;
                    if (currentNameText) {
                        currentNameText.textContent = newUsername;
                    }
                }
            } catch (e) {
                console.error('Error updating chat messages:', e);
            }
        }
        
        // Update Firestore messages with new username
        function updateFirestoreMessagesUsername(oldUsername, oldDisplayName, newUsername) {
            if (!db) return;
            
            // Update public messages
            updateFirestoreCollection('messages', oldUsername, oldDisplayName, newUsername);
            // Update room messages
            updateFirestoreCollection('roomMessages', oldUsername, oldDisplayName, newUsername);
        }
        
        function updateFirestoreCollection(collectionName, oldUsername, oldDisplayName, newUsername) {
            if (!db) return;
            
            const collection = db.collection(collectionName);
            
            // Update messages with old username
            if (oldUsername) {
                collection.where('user', '==', oldUsername).get()
                    .then(querySnapshot => {
                        if (querySnapshot.empty) return;
                        const batch = db.batch();
                        let updateCount = 0;
                        querySnapshot.forEach(doc => {
                            batch.update(doc.ref, { user: newUsername });
                            updateCount++;
                        });
                        if (updateCount > 0) {
                            return batch.commit().then(() => {
                                console.log(`Updated ${updateCount} ${collectionName} messages from ${oldUsername} to ${newUsername}`);
                            });
                        }
                    })
                    .catch(error => {
                        console.error(`Error updating ${collectionName} messages:`, error);
                    });
            }
            
            // Update messages with old displayName (if different from username)
            if (oldDisplayName && oldDisplayName !== oldUsername) {
                collection.where('user', '==', oldDisplayName).get()
                    .then(querySnapshot => {
                        if (querySnapshot.empty) return;
                        const batch2 = db.batch();
                        let updateCount2 = 0;
                        querySnapshot.forEach(doc => {
                            batch2.update(doc.ref, { user: newUsername });
                            updateCount2++;
                        });
                        if (updateCount2 > 0) {
                            return batch2.commit().then(() => {
                                console.log(`Updated ${updateCount2} ${collectionName} messages from ${oldDisplayName} to ${newUsername}`);
                            });
                        }
                    })
                    .catch(error => {
                        console.error(`Error updating ${collectionName} messages:`, error);
                    });
            }
        }
        
        // Expose functions to profile page
        window.updateChatMessagesUsername = updateChatMessagesUsername;
        window.updateFirestoreMessagesUsername = updateFirestoreMessagesUsername;

        // Profanity filter - list of bad words (case-insensitive)
        const badWords = [
            'damn', 'hell', 'crap', 'stupid', 'idiot', 'dumb', 'shut up', 'shutup',
            'hate', 'kill', 'die', 'moron', 'loser', 'ugly', 'fat',
            // Profanity
            'fuck', 'fucking', 'fucked', 'fucker', 'fuckers',
            'shit', 'shitting', 'shitted',
            'ass', 'asses', 'asshole', 'assholes',
            'bitch', 'bitches', 'bitching',
            'bastard', 'bastards',
            'piss', 'pissing', 'pissed',
            'damn', 'damned', 'damnit', 'dammit',
            'crap', 'crappy',
            'dick', 'dicks',
            'cock', 'cocks',
            'pussy', 'pussies',
            'whore', 'whores',
            'slut', 'sluts',
            'niger', 'nigger', 'niggers', 'nigga', 'niggas',
            'retard', 'retarded', 'retards',
            'gay', 'fag', 'fags', 'faggot', 'faggots',
            'cunt', 'cunts',
            'douche', 'douchebag', 'douchebags',
            'screw', 'screwed', 'screwing',
            'suck', 'sucks', 'sucking', 'sucked',
            'bullshit', 'bullshitting',
            'motherfucker', 'motherfuckers',
            'son of a bitch', 'sonofabitch',
            // Add more words as needed
        ];

        // Function to censor bad words in a message
        function censorMessage(message) {
            if (!message || typeof message !== 'string') return message;
            
            let censoredMessage = message;
            const replacement = 'kind word';
            
            // Create regex patterns for each bad word (case-insensitive, word boundaries)
            badWords.forEach(badWord => {
                // Escape special regex characters
                const escapedWord = badWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Match whole words only (case-insensitive)
                const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
                censoredMessage = censoredMessage.replace(regex, replacement);
            });
            
            return censoredMessage;
        }

        // Send message
        function sendMessage() {
            let message = messageInput.value.trim();
            if ((message === '' && !selectedImage && !selectedGif) || !currentUserName) return;

            // Check for chat code secret: "JNJ2025"
            if (message.toLowerCase() === 'jnj2025' && window.secretPages) {
                if (window.secretPages.unlock('chatcode')) {
                    // Redirect is handled in unlockSecret
                } else if (window.secretPages.isUnlocked('chatcode')) {
                    window.location.href = 'secrets.html';
                }
                messageInput.value = '';
                return;
            }

            // Always get the latest username, userId, avatar, and title from profile FIRST
            let messageUsername = currentUserName;
            let messageUserId = null;
            let messageAvatar = 'üë§';
            let messageAvatarImage = null;
            let messageTitle = null;
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (profileData) {
                    const profile = JSON.parse(profileData);
                    
                    // Generate userId for old profiles that don't have one
                    if (!profile.userId) {
                        // Generate a unique user ID
                        function generateUserId() {
                            return 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15);
                        }
                        profile.userId = generateUserId();
                        localStorage.setItem('jnjUserProfile', JSON.stringify(profile));
                        console.log('Generated userId for old profile when sending message:', profile.userId);
                    }
                    
                    // Get userId (required for banning)
                    messageUserId = profile.userId || null;
                    // Use username if available, otherwise use displayName
                    if (profile.username && profile.username.trim() !== '') {
                        messageUsername = profile.username.trim();
                        // Update currentUserName to keep it in sync
                        currentUserName = messageUsername;
                    } else if (profile.displayName && profile.displayName.trim() !== '') {
                        messageUsername = profile.displayName.trim();
                        currentUserName = messageUsername;
                    }
                    // Get avatar
                    if (profile.avatarImage) {
                        messageAvatarImage = profile.avatarImage;
                    } else if (profile.avatar) {
                        messageAvatar = profile.avatar;
                    }
                    // Get title
                    if (profile.equippedTitle) {
                        messageTitle = profile.equippedTitle;
                    }
                    
                    // Track message count and check for title unlocks
                    const messageCount = parseInt(localStorage.getItem('jnjMessageCount') || '0') + 1;
                    localStorage.setItem('jnjMessageCount', messageCount.toString());
                    
                    // Check for title unlocks
                    const newlyUnlocked = checkTitleUnlocks(profile);
                    if (newlyUnlocked.length > 0) {
                        console.log('Unlocked titles:', newlyUnlocked);
                        // Title unlock notification could go here
                    }
                }
            } catch (e) {
                // Ignore errors, use currentUserName
            }
            
            // Censor the message before sending
            message = censorMessage(message);

            const timestamp = Date.now();
            const imageData = selectedImage;
            const gifData = selectedGif;
            
            // Clear image preview
            if (selectedImage) {
                selectedImage = null;
                document.getElementById('imagePreview').style.display = 'none';
                document.getElementById('previewImage').src = '';
                document.getElementById('imageInput').value = '';
            }
            
            // Clear GIF preview
            if (selectedGif) {
                selectedGif = null;
                document.getElementById('gifPreview').style.display = 'none';
                document.getElementById('previewGif').src = '';
            }
            
            console.log('Sending message:', { user: messageUsername, message: message, hasImage: !!imageData, hasGif: !!gifData, gifUrl: gifData, avatar: messageAvatar, avatarImage: !!messageAvatarImage });
            
            // Create a temporary ID based on timestamp to track this message
            const tempMessageId = `temp-${timestamp}-${messageUsername}`;
            
            if (db) {
                // Add to display immediately for better UX (before saving)
                addMessageToChat(messageUsername, message || '', timestamp, false, imageData, gifData, messageAvatar, messageAvatarImage, tempMessageId, messageUserId, messageTitle);
                
                // Save to Firestore, get the real message ID
                saveMessage(messageUsername, message || '', timestamp, imageData, gifData, messageAvatar, messageAvatarImage, messageUserId, messageTitle).then((messageId) => {
                    if (messageId) {
                        // Mark as loaded to prevent duplicate from listener
                        loadedMessageIds.add(messageId);
                        // Update the message element with the real ID
                        const messageElement = chatMessages.querySelector(`[data-message-id="${tempMessageId}"]`);
                        if (messageElement) {
                            messageElement.setAttribute('data-message-id', messageId);
                        }
                    }
                }).catch((error) => {
                    // If save fails, the message is already shown
                    console.error('Error saving message:', error);
                });
            } else {
                addMessageToChat(messageUsername, message || '', timestamp, true, imageData, gifData, messageAvatar, messageAvatarImage, null, messageUserId, messageTitle);
            }
            messageInput.value = '';
            messageInput.focus();
        }
        
        let selectedGif = null; // Store selected GIF URL
        
        // Handle image selection
        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Check file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                alert('Image is too large! Maximum size is 5MB.');
                event.target.value = '';
                return;
            }
            
            // Check if it's an image
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file.');
                event.target.value = '';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                selectedImage = e.target.result; // Store as base64
                document.getElementById('previewImage').src = selectedImage;
                document.getElementById('imagePreview').style.display = 'flex';
            };
            reader.readAsDataURL(file);
        }
        
        // Remove selected image
        function removeImage() {
            selectedImage = null;
            document.getElementById('imagePreview').style.display = 'none';
            document.getElementById('previewImage').src = '';
            document.getElementById('imageInput').value = '';
        }
        
        // Expand image on click
        function expandImage(imgElement) {
            // Remove any existing expanded image
            const existingExpanded = document.querySelector('.expanded-image-overlay');
            if (existingExpanded) {
                existingExpanded.remove();
            }
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'expanded-image-overlay';
            overlay.innerHTML = `
                <div class="expanded-image-container">
                    <button class="close-expanded-image">‚úï</button>
                    <img src="${imgElement.src}" alt="Expanded image" class="expanded-image">
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay || e.target.classList.contains('close-expanded-image')) {
                    overlay.remove();
                }
            });
            
            // Close on Escape key
            const closeHandler = (e) => {
                if (e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', closeHandler);
                }
            };
            document.addEventListener('keydown', closeHandler);
        }

        // Save name handler

        // Generate a 6-digit room code
        function generateRoomCode() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }
        
        // Create a private room
        function createRoom() {
            if (!currentUserName) {
                alert('Please enter your name first.');
                return;
            }
            
            const roomCode = generateRoomCode();
            const roomCreationTime = Date.now();
            currentRoomCode = roomCode;
            localStorage.setItem('jjnChatRoomCode', roomCode);
            
            // Save room metadata to Firestore
            if (db) {
                db.collection('rooms').doc(roomCode).set({
                    code: roomCode,
                    createdAt: roomCreationTime,
                    createdBy: currentUserName
                }, { merge: false })
                .then(() => {
                    console.log('Room created successfully:', roomCode, 'at', new Date(roomCreationTime));
                })
                .catch((error) => {
                    console.error('Error creating room:', error);
                });
            } else {
                // Fallback: save to localStorage
                const rooms = JSON.parse(localStorage.getItem('jjnChatRooms') || '{}');
                rooms[roomCode] = {
                    code: roomCode,
                    createdAt: roomCreationTime,
                    createdBy: currentUserName
                };
                localStorage.setItem('jjnChatRooms', JSON.stringify(rooms));
                console.log('Room saved to localStorage:', roomCode, 'at', new Date(roomCreationTime));
            }
            
            // Update UI
            updateRoomUI();
            
            // Show modal with code to copy
            roomCodeDisplayText.textContent = roomCode;
            roomCodeModal.style.display = 'flex';
            
            // Clear chat and show welcome message for private room
            chatMessages.innerHTML = '<div class="message welcome-message"><div class="message-content"><p>Welcome to Private Room ' + roomCode + '!</p></div></div>';
            loadedMessageIds.clear();
            isInitialLoad = true;
            
            // Load messages for this room (will be empty initially)
            if (db) {
                loadMessagesFromFirestore(roomCode);
            } else {
                // Fallback: reload from localStorage with room filter
                loadMessages();
            }
        }
        
        // Join a private room
        function joinRoom() {
            if (!currentUserName) {
                alert('Please enter your name first.');
                return;
            }
            
            joinRoomModal.style.display = 'flex';
            roomCodeInput.focus();
        }
        
        // Confirm join room
        function confirmJoin() {
            const code = roomCodeInput.value.trim().toLowerCase();
            
            // Special dev code: 000001 redirects to dev secrets page
            if (code === '000001') {
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
                window.location.href = 'dev-secrets.html';
                return;
            }
            
            // Special dev chat room code: "bzn mt" or "bznmt"
            if (code === 'bzn mt' || code === 'bznmt') {
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
                
                // Join the dev chat room
                currentRoomCode = 'devchat';
                localStorage.setItem('jjnChatRoomCode', 'devchat');
                
                // Apply dev chat styling
                document.body.classList.add('dev-chat-active');
                const chatContainer = document.getElementById('chatContainer');
                const chatHeader = document.getElementById('chatHeader');
                const chatTitle = document.getElementById('chatTitle');
                if (chatContainer) chatContainer.classList.add('dev-chat');
                if (chatHeader) chatHeader.classList.add('dev-chat-header');
                if (chatTitle) chatTitle.textContent = 'üîß Dev Chat';
                
                // Update UI
                updateRoomUI();
                
                // Show dev star button
                showDevStarIfNeeded();
                
                
                // Clear chat and show welcome message for dev room
                chatMessages.innerHTML = '<div class="message welcome-message dev-welcome"><div class="message-content"><p>üîß Welcome to Dev Chat Room!</p><p style="margin-top: 10px; font-size: 14px; opacity: 0.8;">This is a secret developer chat room.</p></div></div>';
                loadedMessageIds.clear();
                isInitialLoad = true;
                
                // Load messages for dev room
                if (db) {
                    loadMessagesFromFirestore('devchat');
                } else {
                    // Fallback: reload from localStorage with room filter
                    loadMessages();
                }
                return;
            }
            
            // Regular room code validation (6 digits)
            if (code.length !== 6 || !/^\d+$/.test(code)) {
                alert('Please enter a valid 6-digit room code.');
                return;
            }
            
            // Show loading state
            const originalButtonText = confirmJoinButton.textContent;
            confirmJoinButton.textContent = 'Checking...';
            confirmJoinButton.disabled = true;
            
            // Check if room exists and is valid (created within past week)
            checkRoomValidity(code).then((isValid) => {
                confirmJoinButton.textContent = originalButtonText;
                confirmJoinButton.disabled = false;
                
                if (!isValid) {
                    alert('Room code not found or expired. Rooms expire after 7 days.');
                    roomCodeInput.value = '';
                    return;
                }
                
                // Room is valid, join it
                currentRoomCode = code;
                localStorage.setItem('jjnChatRoomCode', code);
                
                // Update UI
                updateRoomUI();
                
                // Close modal
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
                
                // Clear chat and show welcome message for private room
                chatMessages.innerHTML = '<div class="message welcome-message"><div class="message-content"><p>Welcome to Private Room ' + code + '!</p></div></div>';
                loadedMessageIds.clear();
                isInitialLoad = true;
                
                // Load messages for this room
                if (db) {
                    loadMessagesFromFirestore(code);
                } else {
                    // Fallback: reload from localStorage with room filter
                    loadMessages();
                }
            }).catch((error) => {
                console.error('Error checking room validity:', error);
                confirmJoinButton.textContent = originalButtonText;
                confirmJoinButton.disabled = false;
                alert('Error checking room code. Please try again.');
            });
        }
        
        // Check if a room code is valid (exists and was created within past week)
        function checkRoomValidity(roomCode, retryCount = 0) {
            const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000); // 7 days in milliseconds
            const maxRetries = 3;
            const retryDelay = 500; // 500ms delay between retries
            
            if (db) {
                // Check Firestore
                return db.collection('rooms').doc(roomCode).get()
                    .then((doc) => {
                        if (!doc.exists) {
                            // If room doesn't exist and we haven't retried, wait and try again
                            // This handles the case where room was just created but not yet saved
                            if (retryCount < maxRetries) {
                                console.log(`Room not found, retrying... (${retryCount + 1}/${maxRetries})`);
                                return new Promise((resolve) => {
                                    setTimeout(() => {
                                        checkRoomValidity(roomCode, retryCount + 1).then(resolve);
                                    }, retryDelay);
                                });
                            }
                            console.log('Room does not exist:', roomCode);
                            return false;
                        }
                        
                        const roomData = doc.data();
                        const createdAt = roomData.createdAt || 0;
                        
                        console.log('Room check:', {
                            code: roomCode,
                            createdAt: createdAt,
                            createdAtDate: new Date(createdAt),
                            oneWeekAgo: oneWeekAgo,
                            oneWeekAgoDate: new Date(oneWeekAgo),
                            isValid: createdAt >= oneWeekAgo,
                            timeDiff: Date.now() - createdAt,
                            timeDiffDays: (Date.now() - createdAt) / (24 * 60 * 60 * 1000)
                        });
                        
                        if (createdAt === 0) {
                            console.log('Room has no creation timestamp:', roomCode);
                            return false;
                        }
                        
                        if (createdAt < oneWeekAgo) {
                            console.log('Room expired:', roomCode, 'Created:', new Date(createdAt), 'Now:', new Date());
                            // Optionally delete expired room
                            db.collection('rooms').doc(roomCode).delete().catch(err => console.error('Error deleting expired room:', err));
                            return false;
                        }
                        
                        console.log('Room is valid:', roomCode, 'Created:', new Date(createdAt));
                        return true;
                    })
                    .catch((error) => {
                        console.error('Error checking room in Firestore:', error);
                        // Retry on error if we haven't exceeded max retries
                        if (retryCount < maxRetries) {
                            console.log(`Error checking room, retrying... (${retryCount + 1}/${maxRetries})`);
                            return new Promise((resolve) => {
                                setTimeout(() => {
                                    checkRoomValidity(roomCode, retryCount + 1).then(resolve);
                                }, retryDelay);
                            });
                        }
                        return false;
                    });
            } else {
                // Fallback: check localStorage
                return new Promise((resolve) => {
                    const rooms = JSON.parse(localStorage.getItem('jjnChatRooms') || '{}');
                    const room = rooms[roomCode];
                    
                    if (!room) {
                        console.log('Room does not exist in localStorage:', roomCode);
                        resolve(false);
                        return;
                    }
                    
                    const createdAt = room.createdAt || 0;
                    if (createdAt === 0) {
                        console.log('Room has no creation timestamp in localStorage:', roomCode);
                        resolve(false);
                        return;
                    }
                    
                    if (createdAt < oneWeekAgo) {
                        console.log('Room expired in localStorage:', roomCode);
                        // Remove expired room
                        delete rooms[roomCode];
                        localStorage.setItem('jjnChatRooms', JSON.stringify(rooms));
                        resolve(false);
                        return;
                    }
                    
                    console.log('Room is valid in localStorage:', roomCode);
                    resolve(true);
                });
            }
        }
        
        // Check if user is a dev
        function isDev() {
            try {
                const profileData = localStorage.getItem('jnjUserProfile');
                if (profileData) {
                    const profile = JSON.parse(profileData);
                    return profile.isDev === true;
                }
            } catch (e) {
                console.error('Error checking dev status:', e);
            }
            return false;
        }

        // Check if dev chat is active on page load
        function checkDevChatOnLoad() {
            if (currentRoomCode === 'devchat') {
                document.body.classList.add('dev-chat-active');
                const chatContainer = document.getElementById('chatContainer');
                const chatHeader = document.getElementById('chatHeader');
                const chatTitle = document.getElementById('chatTitle');
                if (chatContainer) chatContainer.classList.add('dev-chat');
                if (chatHeader) chatHeader.classList.add('dev-chat-header');
                if (chatTitle) chatTitle.textContent = 'üîß Dev Chat';
                
                
                // Show dev star button if user is not already a dev
                if (devStarButton) {
                    if (!isDev()) {
                        devStarButton.style.display = 'block';
                        console.log('Showing dev star button - user is not a dev');
                    } else {
                        devStarButton.style.display = 'none';
                        console.log('Hiding dev star button - user is already a dev');
                    }
                } else {
                    console.error('devStarButton element not found!');
                }
            } else {
                if (devStarButton) {
                    devStarButton.style.display = 'none';
                }
            }
        }
        
        // Also check when joining dev chat
        function showDevStarIfNeeded() {
            console.log('showDevStarIfNeeded called', { currentRoomCode, isDev: isDev(), devStarButton: !!devStarButton });
            if (currentRoomCode === 'devchat' && devStarButton) {
                if (!isDev()) {
                    devStarButton.style.display = 'block';
                    devStarButton.style.visibility = 'visible';
                    console.log('Showing dev star button - user is not a dev');
                } else {
                    devStarButton.style.display = 'none';
                    console.log('Hiding dev star button - user is already a dev');
                }
            }
        }
        
        // Handle dev star button click
        if (devStarButton) {
            devStarButton.addEventListener('click', () => {
                if (isDev()) {
                    alert('You are already a dev!');
                    return;
                }
                devPasswordModal.style.display = 'flex';
                devPasswordInput.focus();
            });
        }
        
        // Handle dev password submission
        async function submitDevPasswordHandler() {
            const password = devPasswordInput.value.trim();
            if (password === DEV_PASSWORD) {
                // Save dev status to profile
                try {
                    const profileData = localStorage.getItem('jnjUserProfile');
                    let profile = {};
                    if (profileData) {
                        profile = JSON.parse(profileData);
                    }
                    profile.isDev = true;
                    localStorage.setItem('jnjUserProfile', JSON.stringify(profile));
                    
                    // Also save to Firestore if authenticated
                    if (window.authSystem && window.authSystem.isAuthenticated()) {
                        try {
                            await window.authSystem.saveUserData({ isDev: true });
                        } catch (e) {
                            console.error('Error saving dev status to Firestore:', e);
                        }
                    }
                    
                    // Hide star button and close modal
                    devStarButton.style.display = 'none';
                    devPasswordModal.style.display = 'none';
                    devPasswordInput.value = '';
                    alert('‚≠ê Dev access granted! You now have moderation tools.');
                    
                    // Setup message handlers for newly granted dev
                    setupMessageClickHandlers();
                } catch (e) {
                    console.error('Error saving dev status:', e);
                    alert('Error saving dev status. Please try again.');
                }
            } else {
                alert('Incorrect password!');
                devPasswordInput.value = '';
                devPasswordInput.focus();
            }
        }
        
        if (submitDevPassword) {
            submitDevPassword.addEventListener('click', submitDevPasswordHandler);
        }
        
        if (devPasswordInput) {
            devPasswordInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitDevPasswordHandler();
                }
            });
        }
        
        // Cancel dev password modal
        if (cancelDevPassword) {
            cancelDevPassword.addEventListener('click', () => {
                devPasswordModal.style.display = 'none';
                devPasswordInput.value = '';
            });
        }
        
        // Handle message click for dev users
        function setupMessageClickHandlers() {
            if (!isDev()) return;
            
            const messages = chatMessages.querySelectorAll('.message:not(.welcome-message)');
            messages.forEach(msg => {
                // Remove existing handler to avoid duplicates
                msg.removeEventListener('click', handleMessageClick);
                msg.addEventListener('click', handleMessageClick);
                msg.style.cursor = 'pointer';
                msg.title = 'Click to moderate (Dev only)';
            });
        }
        
        function handleMessageClick(e) {
            if (!isDev()) return;
            
            const messageDiv = e.currentTarget;
            const messageId = messageDiv.getAttribute('data-message-id');
            const userSpan = messageDiv.querySelector('.message-user');
            const username = userSpan ? userSpan.textContent.trim() : 'Unknown';
            // Get userId from message element (preferred)
            let userId = messageDiv.getAttribute('data-user-id');
            
            // If userId not in DOM, try to get it from Firestore
            if (!userId && messageId && db && !messageId.startsWith('temp-')) {
                const roomCode = currentRoomCode || null;
                const collection = roomCode ? 'roomMessages' : 'messages';
                db.collection(collection).doc(messageId).get().then(doc => {
                    if (doc.exists()) {
                        const data = doc.data();
                        if (data.userId) {
                            // Update the DOM element for future reference
                            messageDiv.setAttribute('data-user-id', data.userId);
                        }
                    }
                }).catch(err => {
                    console.error('Error fetching userId from Firestore:', err);
                });
            }
            
            selectedMessageForAction = messageDiv;
            
            messageActionsUser.textContent = `User: ${username}`;
            messageActionsModal.style.display = 'flex';
        }
        
        // Delete message
        if (deleteMessageBtn) {
            deleteMessageBtn.addEventListener('click', () => {
                if (!selectedMessageForAction || !isDev()) return;
                
                const messageId = selectedMessageForAction.getAttribute('data-message-id');
                const roomCode = currentRoomCode || null;
                const collection = roomCode ? 'roomMessages' : 'messages';
                
                console.log('Deleting message:', { messageId, roomCode, collection, hasDb: !!db });
                
                if (db && messageId && !messageId.startsWith('temp-')) {
                    // Mark as deleted in Firestore (don't actually delete)
                    const docRef = db.collection(collection).doc(messageId);
                    docRef.update({
                        deleted: true,
                        deletedAt: firebase.firestore.FieldValue.serverTimestamp()
                    })
                        .then(() => {
                            console.log('Message marked as deleted in Firestore successfully:', messageId);
                            selectedMessageForAction.remove();
                            messageActionsModal.style.display = 'none';
                        })
                        .catch(error => {
                            console.error('Error marking message as deleted in Firestore:', error);
                            console.error('Error details:', error.code, error.message);
                            // Still remove from DOM even if Firestore update fails
                            selectedMessageForAction.remove();
                            messageActionsModal.style.display = 'none';
                            alert('Message removed from view, but there was an error saving deletion. Error: ' + error.message);
                        });
                } else if (db && messageId && messageId.startsWith('temp-')) {
                    // Temp message - just remove from DOM
                    console.log('Removing temp message from DOM');
                    selectedMessageForAction.remove();
                    messageActionsModal.style.display = 'none';
                } else if (!db) {
                    // No Firestore - mark as deleted in localStorage
                    console.log('Marking as deleted in localStorage (no Firestore)');
                    const timestamp = selectedMessageForAction.getAttribute('data-timestamp');
                    const messages = JSON.parse(localStorage.getItem('jjnChatMessages') || '[]');
                    const updatedMessages = messages.map(msg => {
                        if (roomCode) {
                            if (msg.timestamp == timestamp && msg.roomCode === roomCode) {
                                return { ...msg, deleted: true, deletedAt: Date.now() };
                            }
                        } else {
                            if (msg.timestamp == timestamp && !msg.roomCode) {
                                return { ...msg, deleted: true, deletedAt: Date.now() };
                            }
                        }
                        return msg;
                    });
                    localStorage.setItem('jjnChatMessages', JSON.stringify(updatedMessages));
                    selectedMessageForAction.remove();
                    messageActionsModal.style.display = 'none';
                } else {
                    // No message ID - just remove from DOM
                    console.log('No message ID, removing from DOM only');
                    selectedMessageForAction.remove();
                    messageActionsModal.style.display = 'none';
                }
            });
        }
        
        // Cancel message actions
        if (cancelMessageActions) {
            cancelMessageActions.addEventListener('click', () => {
                messageActionsModal.style.display = 'none';
                selectedMessageForAction = null;
            });
        }
        
        // Leave private room and return to public chat
        function leaveRoom() {
            if (!confirm('Leave this private room and return to public chat?')) {
                return;
            }
            
            // Remove dev chat styling if active
            document.body.classList.remove('dev-chat-active');
            const chatContainer = document.getElementById('chatContainer');
            const chatHeader = document.getElementById('chatHeader');
            const chatTitle = document.getElementById('chatTitle');
            if (chatContainer) chatContainer.classList.remove('dev-chat');
            if (chatHeader) chatHeader.classList.remove('dev-chat-header');
            if (chatTitle) chatTitle.textContent = 'JNJ Chat';
            
            
            currentRoomCode = null;
            localStorage.removeItem('jjnChatRoomCode');
            
            // Update UI
            updateRoomUI();
            
            // Clear chat and show welcome message for public chat
            chatMessages.innerHTML = '<div class="message welcome-message"><div class="message-content"><p>Welcome to JNJ Chat! Start a conversation below.</p></div></div>';
            loadedMessageIds.clear();
            isInitialLoad = true;
            
            // Load public messages
            if (db) {
                loadMessagesFromFirestore(null);
            } else {
                // Fallback: reload from localStorage
                loadMessages();
            }
        }
        
        // Copy room code to clipboard
        function copyRoomCode() {
            const code = roomCodeDisplayText.textContent;
            navigator.clipboard.writeText(code).then(() => {
                copyRoomCodeButton.textContent = '‚úì';
                copyRoomCodeButton.style.background = 'rgba(81, 207, 102, 0.3)';
                setTimeout(() => {
                    copyRoomCodeButton.textContent = 'üìã';
                    copyRoomCodeButton.style.background = '';
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = code;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                copyRoomCodeButton.textContent = '‚úì';
                setTimeout(() => {
                    copyRoomCodeButton.textContent = 'üìã';
                }, 2000);
            });
        }
        
        // Event listeners
        sendButton.addEventListener('click', () => {
            sendMessage();
        });
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        document.getElementById('imageInput').addEventListener('change', handleImageSelect);
        document.getElementById('removeImageButton').addEventListener('click', removeImage);
        document.getElementById('removeGifButton').addEventListener('click', () => {
            selectedGif = null;
            document.getElementById('gifPreview').style.display = 'none';
            document.getElementById('previewGif').src = '';
        });
        
        // Emoji picker
        const commonEmojis = ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú', 'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥', 'üòè', 'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ', '‚òπÔ∏è', 'üò£', 'üòñ', 'üò´', 'üò©', 'ü•∫', 'üò¢', 'üò≠', 'üò§', 'üò†', 'üò°', 'ü§¨', 'ü§Ø', 'üò≥', 'ü•µ', 'ü•∂', 'üò±', 'üò®', 'üò∞', 'üò•', 'üòì', 'ü§ó', 'ü§î', 'ü§≠', 'ü§´', 'ü§•', 'üò∂', 'üòê', 'üòë', 'üò¨', 'üôÑ', 'üòØ', 'üò¶', 'üòß', 'üòÆ', 'üò≤', 'ü•±', 'üò¥', 'ü§§', 'üò™', 'üòµ', 'ü§ê', 'ü•¥', 'ü§¢', 'ü§Æ', 'ü§ß', 'üò∑', 'ü§í', 'ü§ï', 'ü§ë', 'ü§†', 'üòà', 'üëø', 'üëπ', 'üë∫', 'ü§°', 'üí©', 'üëª', 'üíÄ', '‚ò†Ô∏è', 'üëΩ', 'üëæ', 'ü§ñ', 'üéÉ', 'üò∫', 'üò∏', 'üòπ', 'üòª', 'üòº', 'üòΩ', 'üôÄ', 'üòø', 'üòæ'];
        
        function initEmojiPicker() {
            emojiGrid.innerHTML = '';
            commonEmojis.forEach(emoji => {
                const emojiButton = document.createElement('button');
                emojiButton.className = 'emoji-item';
                emojiButton.textContent = emoji;
                emojiButton.title = emoji;
                emojiButton.addEventListener('click', () => {
                    const cursorPos = messageInput.selectionStart;
                    const textBefore = messageInput.value.substring(0, cursorPos);
                    const textAfter = messageInput.value.substring(cursorPos);
                    messageInput.value = textBefore + emoji + textAfter;
                    messageInput.focus();
                    messageInput.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);
                    emojiPickerModal.style.display = 'none';
                });
                emojiGrid.appendChild(emojiButton);
            });
        }
        
        // GIF picker functions
        async function loadGIFs(query = 'trending') {
            gifGrid.innerHTML = '<div class="gif-loading">Loading GIFs...</div>';
            
            // If no API key, use a fallback or show message
            if (GIPHY_API_KEY === 'YOUR_GIPHY_API_KEY') {
                gifGrid.innerHTML = '<div class="gif-error">Please add your Giphy API key in chat.html. Get one free at <a href="https://developers.giphy.com/" target="_blank">developers.giphy.com</a></div>';
                return;
            }
            
            try {
                let url;
                if (query === 'trending' || query === '') {
                    url = `https://api.giphy.com/v1/gifs/trending?api_key=${GIPHY_API_KEY}&limit=24&rating=g`;
                } else {
                    url = `https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=24&rating=g`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                gifGrid.innerHTML = '';
                
                if (data.data && data.data.length > 0) {
                    data.data.forEach(gif => {
                        const gifItem = document.createElement('div');
                        gifItem.className = 'gif-item';
                        const gifImg = document.createElement('img');
                        gifImg.src = gif.images.fixed_height_small.url;
                        gifImg.alt = gif.title || 'GIF';
                        gifImg.loading = 'lazy';
                        gifImg.addEventListener('click', () => {
                            selectedGif = gif.images.original.url;
                            console.log('GIF selected:', selectedGif);
                            document.getElementById('previewGif').src = selectedGif;
                            document.getElementById('gifPreview').style.display = 'flex';
                            gifPickerModal.style.display = 'none';
                            gifSearchInput.value = '';
                        });
                        gifItem.appendChild(gifImg);
                        gifGrid.appendChild(gifItem);
                    });
                } else {
                    gifGrid.innerHTML = '<div class="gif-error">No GIFs found. Try a different search.</div>';
                }
            } catch (error) {
                console.error('Error loading GIFs:', error);
                gifGrid.innerHTML = '<div class="gif-error">Error loading GIFs. Please check your API key.</div>';
            }
        }
        
        // Event listeners for emoji and GIF pickers
        emojiButton.addEventListener('click', () => {
            emojiPickerModal.style.display = 'flex';
            initEmojiPicker();
        });
        
        gifButton.addEventListener('click', () => {
            gifPickerModal.style.display = 'flex';
            loadGIFs('trending');
        });
        
        closeEmojiPicker.addEventListener('click', () => {
            emojiPickerModal.style.display = 'none';
        });
        
        closeGifPicker.addEventListener('click', () => {
            gifPickerModal.style.display = 'none';
            gifSearchInput.value = '';
        });
        
        gifSearchButton.addEventListener('click', () => {
            const query = gifSearchInput.value.trim();
            loadGIFs(query || 'trending');
        });
        
        gifSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const query = gifSearchInput.value.trim();
                loadGIFs(query || 'trending');
            }
        });
        
        emojiPickerModal.addEventListener('click', (e) => {
            if (e.target === emojiPickerModal) {
                emojiPickerModal.style.display = 'none';
            }
        });
        
        gifPickerModal.addEventListener('click', (e) => {
            if (e.target === gifPickerModal) {
                gifPickerModal.style.display = 'none';
                gifSearchInput.value = '';
            }
        });
        
        // Room event listeners
        createRoomButton.addEventListener('click', createRoom);
        joinRoomButton.addEventListener('click', joinRoom);
        leaveRoomButton.addEventListener('click', leaveRoom);
        copyRoomCodeButton.addEventListener('click', copyRoomCode);
        closeRoomCodeModal.addEventListener('click', () => {
            roomCodeModal.style.display = 'none';
        });
        confirmJoinButton.addEventListener('click', confirmJoin);
        cancelJoinButton.addEventListener('click', () => {
            joinRoomModal.style.display = 'none';
            roomCodeInput.value = '';
        });
        roomCodeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                confirmJoin();
            }
        });
        roomCodeModal.addEventListener('click', (e) => {
            if (e.target === roomCodeModal) {
                roomCodeModal.style.display = 'none';
            }
        });
        joinRoomModal.addEventListener('click', (e) => {
            if (e.target === joinRoomModal) {
                joinRoomModal.style.display = 'none';
                roomCodeInput.value = '';
            }
        });

        
        // Initialize on page load
        loadUserName();
        loadMessages();
        
        // Cursor Trail Effect - Smooth line effect
        const trails = [];
        const maxTrails = 50;
        let lastTime = 0;
        
        function createCursorTrail(x, y, delay = 0) {
            setTimeout(() => {
                const trail = document.createElement('div');
                trail.className = 'cursor-trail';
                trail.style.left = x + 'px';
                trail.style.top = y + 'px';
                trail.style.opacity = '0.6';
                document.body.appendChild(trail);
                
                requestAnimationFrame(() => {
                    trail.style.opacity = '0';
                    trail.style.transform = 'translate(-50%, -50%) scale(0.2)';
                });
                
                setTimeout(() => {
                    if (trail.parentNode) {
                        trail.remove();
                    }
                }, 800);
                
                trails.push(trail);
                if (trails.length > maxTrails) {
                    const oldTrail = trails.shift();
                    if (oldTrail && oldTrail.parentNode) {
                        oldTrail.remove();
                    }
                }
            }, delay);
        }
        
        let lastX = 0;
        let lastY = 0;
        let mouseX = 0;
        let mouseY = 0;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            const now = Date.now();
            const timeSinceLastTrail = now - lastTime;
            
            if (timeSinceLastTrail > 8) {
                const distance = Math.sqrt(
                    Math.pow(mouseX - lastX, 2) + Math.pow(mouseY - lastY, 2)
                );
                
                if (distance > 2) {
                    createCursorTrail(mouseX, mouseY);
                    lastX = mouseX;
                    lastY = mouseY;
                    lastTime = now;
                }
            }
        });
    </script>
</body>
</html>

