<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phantom's Paradise</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="phantomsparadise.css">
    <link rel="stylesheet" href="animated-background.css">
    <link rel="stylesheet" href="background-music.css">
    <script src="page-transitions.js" defer></script>
    <script src="animated-background.js" defer></script>
    <script src="background-music.js" defer></script>
</head>
<body>
    <a href="songs.html" class="back-button">‚Üê Back to Songs</a>
    <div class="player-container">
    <figure>
        <figcaption>Listen to Phantom's Paradise:</figcaption>
            <p class="credits">by: JNJ (Junhu Choi, Jaxon Croskey, Nathan DeLuca)</p>
        <audio id="audioPlayer" controls src="phantomtaxersparadise.mp3"></audio>
        <a href="phantomtaxersparadise.mp3"> Download audio </a>
    </figure>
        
        <div class="controls-panel">
            <div class="control-group">
                <button class="control-button" onclick="skipBack(30)" title="Skip back 30 seconds">‚è™</button>
                <button class="control-button" onclick="skipBack(10)" title="Skip back 10 seconds">‚èÆ</button>
                <button class="control-button" onclick="skipAhead(10)" title="Skip ahead 10 seconds">‚è≠</button>
                <button class="control-button" onclick="skipAhead(30)" title="Skip ahead 30 seconds">‚è©</button>
            </div>
            <div class="control-group">
                <button class="control-button" onclick="toggleLyrics()" title="Toggle lyrics visibility">üëÅÔ∏è</button>
                <button class="control-button" onclick="resetTypewriter()" title="Reset lyrics">‚Üª</button>
                <button class="control-button" onclick="showAllLyrics()" title="Show all lyrics">üìÑ</button>
            </div>
        </div>
    </div>
    
    <div class="lyrics-container" id="lyricsContainer">
        <div class="lyrics-text" id="lyricsDisplay"></div>
    </div>

    <script>
        const audio = document.getElementById('audioPlayer');
        const lyricsDisplay = document.getElementById('lyricsDisplay');
        const lyricsContainer = document.getElementById('lyricsContainer');
        
        // Lyrics text
        const lyrics = `As I walk through the hallway of the elementary zone  
I take a look at my pad and realize it's almost gone  
'Cause I been tappin' and swipin' so long that  
Even my teacher thinks my tech game's strong

But I ain't never crossed a phantom who didn't tax a screen  
He creepin' through the Wi-Fi, takin' what he needs  
You better watch your apps, better hide your stash  
He's skimming off the top like digital cash

I really hate to whine, but I gotta moan  
He took my Roblox coins and left me alone  
I'm the kind of kid the playground's hypin'  
On my iPad grind while the phantom's siphonin'

Been spendin' most my life  
Livin' in a phantom's paradise  
He taxes all our bytes  
Livin' in a phantom taxers paradise 

He don't need a mask, he don't need a name  
He just reroutes your data like it's part of a game  
He got no chill, he got no shame  
He even taxed my grandma's Candy Crush fame

Power and pixels, minute by minute  
The more we tap, the more he's in it  
Everybody's swipin', nobody's winnin'  
He's ghostin' our screens while we just grinnin'

Tell me why are we so blind to see  
That the phantom lives in our USB?

Been spendin' most my life  
Livin' in a phantom's paradise  
He taxes all our bytes  
Livin' in a phantom's paradise`;
        
        let typewriterInterval = null;
        let currentIndex = 0;
        let isTyping = false;
        let typingSpeed = 80; // milliseconds per character (normal speed)
        const START_DELAY = 0; // Start typing immediately when audio starts
        let lyricsVisible = true;
        let showAllActive = false; // Flag to prevent sync when "Show All" is active

        // Calculate how many characters should be displayed based on current time
        function calculateCharacterIndex(currentTime) {
            const timeSinceStart = Math.max(0, currentTime - START_DELAY);
            const charactersPerSecond = 1000 / typingSpeed;
            return Math.floor(timeSinceStart * charactersPerSecond);
        }

        function typeWriter() {
            if (currentIndex < lyrics.length) {
                const char = lyrics[currentIndex];
                lyricsDisplay.textContent += char;
                currentIndex++;
            } else {
                clearInterval(typewriterInterval);
                isTyping = false;
            }
        }

        function startTypewriter() {
            if (!isTyping) {
                // If we're resuming from a pause, don't reset
                if (currentIndex === 0) {
                    lyricsDisplay.textContent = '';
                }
                isTyping = true;
                typewriterInterval = setInterval(typeWriter, typingSpeed);
            }
        }

        function resetTypewriter() {
            showAllActive = false; // Reset show all flag
            clearInterval(typewriterInterval);
            lyricsDisplay.textContent = '';
            currentIndex = 0;
            isTyping = false;
        }

        function pauseTypewriter() {
            clearInterval(typewriterInterval);
            isTyping = false;
        }

        function syncTypewriterWithAudio() {
            // Don't sync if "Show All" is active
            if (showAllActive) {
                return;
            }
            // Sync typewriter position with audio time
            const targetIndex = calculateCharacterIndex(audio.currentTime);
            if (targetIndex !== currentIndex) {
                clearInterval(typewriterInterval);
                lyricsDisplay.textContent = lyrics.substring(0, targetIndex);
                currentIndex = targetIndex;
                
                if (targetIndex < lyrics.length && !audio.paused && audio.currentTime >= START_DELAY) {
                    isTyping = true;
                    typewriterInterval = setInterval(typeWriter, typingSpeed);
                } else {
                    isTyping = false;
                }
            }
        }

        function checkStartTime() {
            if (audio.currentTime >= START_DELAY && !isTyping && !audio.paused) {
                syncTypewriterWithAudio();
            }
        }

        // Skip functions
        function skipAhead(seconds) {
            showAllActive = false; // Reset show all when skipping
            const newTime = Math.min(audio.duration || audio.currentTime + seconds, audio.currentTime + seconds);
            audio.currentTime = newTime;
            syncTypewriterWithAudio();
        }

        function skipBack(seconds) {
            showAllActive = false; // Reset show all when skipping
            const newTime = Math.max(0, audio.currentTime - seconds);
            audio.currentTime = newTime;
            syncTypewriterWithAudio();
        }

        // Toggle lyrics visibility
        function toggleLyrics() {
            lyricsVisible = !lyricsVisible;
            const container = document.getElementById('lyricsContainer');
            if (lyricsVisible) {
                container.style.display = 'block';
            } else {
                container.style.display = 'none';
            }
        }

        // Show all lyrics instantly
        function showAllLyrics() {
            showAllActive = true; // Set flag to prevent sync from overwriting
            clearInterval(typewriterInterval);
            lyricsDisplay.textContent = lyrics;
            currentIndex = lyrics.length;
            isTyping = false;
        }

        // Audio event listeners
        audio.addEventListener('timeupdate', () => {
            if (!showAllActive) {
                checkStartTime();
                // Sync typewriter position periodically
                if (audio.currentTime >= START_DELAY) {
                    syncTypewriterWithAudio();
                }
            }
        });
        audio.addEventListener('pause', pauseTypewriter);
        audio.addEventListener('seeked', () => {
            if (!showAllActive) {
                syncTypewriterWithAudio();
            }
        });
        audio.addEventListener('ended', () => {
            clearInterval(typewriterInterval);
            isTyping = false;
        });
        
        
        // Handle case where audio might already be playing when page loads
        if (!audio.paused && audio.currentTime >= START_DELAY) {
            syncTypewriterWithAudio();
        }
        
        // Cursor Trail Effect - Smooth line effect
        const trails = [];
        const maxTrails = 50;
        let lastTime = 0;
        
        function createCursorTrail(x, y, delay = 0) {
            setTimeout(() => {
                const trail = document.createElement('div');
                trail.className = 'cursor-trail';
                trail.style.left = x + 'px';
                trail.style.top = y + 'px';
                trail.style.opacity = '0.6';
                document.body.appendChild(trail);
                
                requestAnimationFrame(() => {
                    trail.style.opacity = '0';
                    trail.style.transform = 'translate(-50%, -50%) scale(0.2)';
                });
                
                setTimeout(() => {
                    if (trail.parentNode) {
                        trail.remove();
                    }
                }, 800);
                
                trails.push(trail);
                if (trails.length > maxTrails) {
                    const oldTrail = trails.shift();
                    if (oldTrail && oldTrail.parentNode) {
                        oldTrail.remove();
                    }
                }
            }, delay);
        }
        
        let lastX = 0;
        let lastY = 0;
        let mouseX = 0;
        let mouseY = 0;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            const now = Date.now();
            const timeSinceLastTrail = now - lastTime;
            
            if (timeSinceLastTrail > 8) {
                const distance = Math.sqrt(
                    Math.pow(mouseX - lastX, 2) + Math.pow(mouseY - lastY, 2)
                );
                
                if (distance > 2) {
                    createCursorTrail(mouseX, mouseY);
                    lastX = mouseX;
                    lastY = mouseY;
                    lastTime = now;
                }
            }
        });
    </script>
</body>
</html>

